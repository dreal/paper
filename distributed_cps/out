Binary files ./.DS_Store and /Users/kquine/Downloads/texfiles/.DS_Store differ
Only in .: IEEEtran.cls
Only in .: Onion-f.graffle
Only in .: Onion-f.pdf
Only in .: Onion-s.graffle
Only in .: Onion-s.pdf
Only in /Users/kquine/Downloads/texfiles/: abstract-1.tex
Only in /Users/kquine/Downloads/texfiles/: case-studies-1.tex
diff ./case-studies.tex /Users/kquine/Downloads/texfiles/case-studies.tex
215c215,216
< Figure~\ref{fig:water}.  %\textbf{KYUNGMIN: I cannot see on Fig 8 that  they are connected ...}
---
> Figure~\ref{fig:water}.  \textbf{KYUNGMIN: I cannot see on Fig 8 that
>   they are connected ...}
Only in /Users/kquine/Downloads/texfiles/: concl-1.tex
diff ./concl.tex /Users/kquine/Downloads/texfiles/concl.tex
1,35c1,35
< % !TEX root = /Users/kquine/Dropbox/Research/Papers/2015/CPS-SMT-RTSS/cps-rtss.tex
< 
< \section{Concluding Remarks}
< \label{sec:concl}
< 
< %%% OK, Kyungmin, I am trying here myself ...
< 
< We have presented and proved the correctness of the Hybrid PALS
< methodology that  greatly simplifies the design and verification of
< virtually synchronous cyber-physical systems whose components have
< environments with continuous behaviors.  Although Hybrid PALS does not
< allow us to abstract from (imprecise) local clocks and the times
< transitions are performed, it allows us to abstract from asynchronous
< communication (and the resulting interleavings), message buffering,
< network delays, 
< backoff timers, and so on.
< 
< 
< 
< 
< 
< 
< 
< % We have presented Hybrid PALS to reduce the system complexity of distributed cyber-physical systems,
< % shows a bisimulation equivalence relating a distributed hybrid PALS model and its underlying synchronous model. 
< We have shown that verification problems for Hybrid PALS models can be
< expressed as SMT formulas and have developed % a number of techniques 
< % We have presented an extended logical theory for distributed hybrid systems and provided an
< efficient  SMT-solving-based verification methods for Hybrid PALS. 
< We have implemented these techniques in the \textsf{dReal} SMT solver and   have
< applied our methodology on a number of non-trivial CPSs. Our
< experiments have shown that our techniques dramatically increase the
< performance of SMT analysis for distributed hybrid systems with
< multiple control modes and nonlinear ODEs up to precision $\delta$. 
< %\textbf{(Peter) Kyungmin, maybe more is needed in this last paragraph;
---
> % !TEX root = /Users/kquine/Dropbox/Research/Papers/2015/CPS-SMT-RTSS/cps-rtss.tex
> 
> \section{Concluding Remarks}
> \label{sec:concl}
> 
> %%% OK, Kyungmin, I am trying here myself ...
> 
> We have presented and proved the correctness of the Hybrid PALS
> methodology that  greatly simplifies the design and verification of
> virtually synchronous cyber-physical systems whose components have
> environments with continuous behaviors.  Although Hybrid PALS does not
> allow us to abstract from (imprecise) local clocks and the times
> transitions are performed, it allows us to abstract from asynchronous
> communication (and the resulting interleavings), message buffering,
> network delays, 
> backoff timers, and so on.
> 
> 
> 
> 
> 
> 
> 
> % We have presented Hybrid PALS to reduce the system complexity of distributed cyber-physical systems,
> % shows a bisimulation equivalence relating a distributed hybrid PALS model and its underlying synchronous model. 
> We have shown that verification problems for Hybrid PALS models can be
> expressed as SMT formulas and have developed % a number of techniques 
> % We have presented an extended logical theory for distributed hybrid systems and provided an
> efficient  SMT-solving-based verification methods for Hybrid PALS. 
> We have implemented these techniques in the \textsf{dReal} SMT solver and   have
> applied our methodology on a number of non-trivial CPSs. Our
> experiments have shown that our techniques dramatically increase the
> performance of SMT analysis for distributed hybrid systems with
> multiple control modes and nonlinear ODEs up to precision $\delta$. 
> %\textbf{(Peter) Kyungmin, maybe more is needed in this last paragraph;
Only in /Users/kquine/Downloads/texfiles/: cps-rtss-1.tex
Only in .: cps-rtss.aux
Only in .: cps-rtss.bbl
Only in .: cps-rtss.blg
Only in .: cps-rtss.log
Only in .: cps-rtss.pdf
Only in .: cps-rtss.synctex.gz
Only in .: ensemble.graffle
Only in .: ensemble.pdf
Only in /Users/kquine/Downloads/texfiles/: hybrid-pals-1.tex
diff ./hybrid-pals.tex /Users/kquine/Downloads/texfiles/hybrid-pals.tex
1,444c1,444
< % !TEX root = /Users/kquine/Dropbox/Research/Papers/2015/CPS-SMT-RTSS/cps-rtss.tex
< 
< \section{Hybrid PALS}
< \label{sec:hybrid-pals}
< 
< 
< %\textbf{(Peter) Some very important overview text added!}
< 
< This section presents \emph{Hybrid PALS}, which extends PALS to hybrid
< systems.  One main difference between PALS and Hybrid PALS is that
<  the time at which an event takes place does not matter in PALS, as
< long as it happens within a certain time interval. This
<  allows us to relate a distributed
< real-time system to an essentially untimed synchronous model. However,
< in hybrid systems, we cannot abstract from the time at which a
< continuous value is read or  an actuator command is given
< (both of which depend on a component's imprecise local clock). Therefore,
< the precise times at which these events happen must be included also
< in the \emph{synchronous} Hybrid PALS models to have any possibility
< of an equivalence between the synchronous model and the distributed
< hybrid system. 
< 
< 
< In Hybrid PALS, a  state of a physical environment %of a machine $M$ 
< is 
< a tuple $\vec{v} = (v_1,\ldots,v_l) \in \mathbb{R}^l$ 
< of its physical parameters $\vec{x} = (x_1, \ldots,x_l)$,
< and
< the behavior of %the physical parameters 
< $\vec{x}$
< can be modeled by ODEs that specify \emph{trajectories} 
< $\tau_1, \ldots, \tau_l$ of %the parameters 
< $\vec{x}$ over time.
< %
< %The continuous dynamics %of the system 
< %is specified by \emph{controlled physical environments} $E$.
< The standard PALS models $\mathcal{E}$ and $\mathcal{MA}(\mathcal{E},T,\Gamma)$ 
< are  nondeterministic models defined for \emph{any possible} environment behaviors.
< The \emph{environment restrictions} 
< $\mathcal{MA}(\mathcal{E},T,\Gamma)\restriction E$
< and
< $\mathcal{E} \restriction E$
< %introduced in~\cite{hybrid-pals}, 
<  define the behavior of the models 
<  constrained by the physical  environment $E$.  To have any
<  control over when values are read from, and sent to, physical environments, we add in this paper \emph{sampling and
<    response timing policies} to the Hybrid PALS models. 
< We then  
< prove a bisimulation equivalence 
< relating $\mathcal{E}\restriction E$ and $\mathcal{MA}(\mathcal{E}, T,\Gamma)\restriction E$,
< %with respect to physical environments,
< which generalizes the  trace equivalence result in \cite{hybrid-pals}.
< 
< 
< 
< \subsection{Controlled Physical Environments}
< 
< %Let $\vec{\tau}(t) = (\tau_1(t),\ldots,\tau_l(t))$
< %for an l-tuple of trajectories 
< %$\vec{\tau} = (\tau_1,\ldots,\tau_l)$.
< %Notice that the parameters $\vec{x}$ are also trajectories
< %in such a way that a state of  the physical environment at time $t$
< 
< 
< A (local)  %physical 
< environment $E_M$ of machine $M$
< is specified as a   \emph{controlled physical environment}
< that defines every possible trajectory of its physical parameters %$\vec{x}$
< for the control commands from $M$.
< %
< For a state $\vec{v} \in \mathbb{R}^l$, a control command $a$, and a duration $t \in \mathbb{R}$,
< a %controlled 
< physical environment $E_M$
< gives a trajectory $\vec{\tau}$ of its parameters $\vec{x}$ of duration $t$,
< as illustrated in Fig.~\ref{fig:physical-transition}.
< %(e.g., state $v_1$, command $a$, duration $t_2-t_1$ yields trajectory $\tau_1$).
< 
< \begin{definition}
< Let  $\mathcal{T}$ denote the set of all
< trajectories (a trajectory of duration $T$ is a function $\tau : [0,T] \rightarrow \mathbb{R}$).
< A \emph{controlled physical environment} $E_M = (C, \vec{x}, \Lambda)$ consists of:
< \begin{inparaenum}[(i)]
<     \item $C$ a set of \emph{control commands}; %(or ``actuator outputs'') from  $M$;
<     \item $\vec{x} = (x_1, \ldots,x_l)$ a vector of real number variables; and
<     \item $\Lambda \subseteq (C \times \mathbb{R}_{\geq 0} \times \mathbb{R}^l) \times \mathcal{T}^l$
<     a \emph{physical transition relation}, where
<     $((a, t, \vec{v}),  \vec{\tau}) \in \Lambda$
<     iff for a control command $a \in C$ that lasts 
<     for duration~$t$, 
<     $E_M$'s physical state $\vec{x}$ follows the trajectory 
<     $\vec{\tau} \in \mathcal{T}^l$
<     from $\vec{v} \in \mathbb{R}^l$ with
<         $\vec{\tau}(0) = \vec{v}$.
< \end{inparaenum}
< (E.g., $((a_1,t_2-t_1,v_1), \tau_1) \in \Lambda$ in Fig.~\ref{fig:physical-transition}).
< \end{definition}
< 
< \begin{figure}
< \centering
< \begin{tikzpicture}[xscale=2.5,yscale=1.39,font=\footnotesize]
< %baseline
< \draw[-latex,thin] (-0.1,0) -- (3.2,0);
< \draw[shift={(0,0)},thin,dashed] (0,1.1) -- (0,-0.05) node[below] {\footnotesize $t_0$};
< \draw[shift={(0.7,0)},thin,dashed] (0,1.1) -- (0,-0.05) node[below] {\footnotesize $t_1$};
< \draw[shift={(2.1,0)},thin,dashed] (0,1.1) -- (0,-0.05) node[below] {\footnotesize $t_2$};
< \draw[shift={(3,0)},thin,dashed] (0,1.1) -- (0,-0.05) node[below] {\footnotesize $t_3$};
< %curves
< \begin{scope}[yshift=6pt]
< \filldraw (0,0.21) circle (0.5pt) node[below,xshift=-1.2ex] {$v_0$};
< \draw (0,0.21) .. controls (0.3,0.15) and (0.4,0.5) .. node[above,sloped] (t0) {$\tau_0$} (0.7,0.35);
< \draw[-open triangle 45,very thin] ($(t0.north) + (-0.1,0.15)$) node[above] {$a_0$} -- ($(t0.north) + (-0.02,0.02)$);
<     \filldraw (0.7,0.35) circle (0.5pt) node[below,xshift=-1.2ex] {$v_1$};
<     \draw (0.7,0.35) .. controls (1.3,0.25) and (1.6,0.4) .. node[above,sloped] (t1) {$\tau_1$} (2.1,0.6);
<     \draw[-open triangle 45,very thin] ($(t1.north) + (-0.2,0.15)$) node[left,yshift=2pt] {$a_1$} -- ($(t1.north) + (-0.02,0.02)$);
< 	\filldraw (2.1,0.6) circle (0.5pt) node[above,xshift=-1.2ex] {$v_2$};
< 	\draw (2.1,0.6) .. controls (2.6,0.7) and (2.7,0.7) .. node[above,sloped] (t2) {$\tau_2$} (3,0.77);
< 	\draw[-open triangle 45,very thin] ($(t2.west) + (-0.15,0.05)$) node[left,yshift=1pt] {$a_2$} -- ($(t2.west) + (-0.02,0.01)$);
< 	    \filldraw (3,0.77) circle (0.5pt) node[right,yshift=1ex] {$v_3$};
< 	\draw (2.1,0.6) .. controls (2.6,0.7) and (2.7,0.4) .. node[below,sloped] (t2') {$\tau_2'$} (3,0.57);
< 	    \filldraw (3,0.57) circle (0.5pt) node[right,yshift=-0.2ex] {$v_3'$};
< 	\draw[-open triangle 45,very thin] ($(t2'.west) + (-0.15,-0.1)$) node[left,yshift=-1pt] {$a_2'$} -- ($(t2'.west) + (-0.02,-0.02)$);
< 
<     \draw (0.7,0.35) .. controls (1.3,0.15) and (1.6,0.5) .. node[below,sloped] (t1') {$\tau_1'$} (2.1,0.1);
<     \draw[-open triangle 45,very thin] ($(t1'.south) + (-0.2,-0.15)$) node[left,yshift=-2pt] {$a_1'$} -- ($(t1'.south) + (-0.02,-0.02)$);
< 	\filldraw (2.1,0.1) circle (0.5pt) node[below,xshift=-1.5ex] {$v_2'$};
< 	\draw (2.1,0.1) .. controls (2.6,-0.1) and (2.7,0.3) .. node[below,sloped] (t2''){$\tau_2''$} (3,0.2);
< 	\draw[-open triangle 45,very thin] ($(t2''.west) + (-0.15,-0.05)$) node[left,yshift=-1pt] {$a_2''$} -- ($(t2''.west) + (-0.02,-0.02)$);
< 	    \filldraw (3,0.2) circle (0.5pt) node[right,yshift=-1.5ex] {$v_3''$};;;
< \end{scope}
< \end{tikzpicture}
< \caption{A controlled physical environment $E_M$.}
< \label{fig:physical-transition}
< \end{figure}
< 
< 
< Several physical environments may be physically correlated,
< and one %local 
< environment may % immediately
< affect  another environment.
< Such %physical 
< correlations are %naturally 
< expressed as
< \emph{time-invariant constraints} $(\forall t.\, \psi)$ of physical parameters over time $t$.
< %(e.g., some parameter of one physical environment should always 
< %  equal some other  parameter of another physical environment).
< For example, if %physical 
< parameter $x_1$ of $E_{M_1}$
< must be equal to  parameter $x_2$ of %another environment 
< $E_{M_2}$,
< then the time-invariant constraint is  %the formula
< $\forall t.\; x_1(t) = x_2(t)$.
< %\footnote{Without loss of generality, we assume that different parameter names of different components are all different.}
< %with variable $t$ for time.
< 
< 
< 
< 
< \subsection{Environment-Restricted Controllers}
< \label{sec:env-res}
< 
< A controller $M$ is a \emph{nondeterministic} machine
< parameterized by any behavior of its %physical 
< environment $E_M$.
< %
< The controller 
< $M$ interacts  with %its physical environment 
< $E_M$
< according to its local clock,
< which may  differ from global time by up to  
< the maximal clock skew $\epsilon$.
< Let $c_M : \mathbb{N} \to \mathbb{R}_{>0}$ denote a a \emph{periodic local clock} of $M$
< that gives the \emph{global time} at the
< beginning of the $(i+1)$-th period according to $M$'s local clock. 
< That is,  $c_M(0) = 0$
< and
< $c_M(n) \in (n T - \epsilon, n T + \epsilon)$ for each $n > 0$.
< 
< 
< 
< \begin{figure}
< \centering
< \begin{tikzpicture}[xscale=2.5,yscale=1.68,font=\footnotesize]
< %baseline
< \draw[-latex,thin] (-0.2,0) -- (3.3,0);
< \draw[-latex,thin] (-0.2,0.8) -- (3.3,0.8);
< 
< \draw[thin] (0.4,0.82) -- (0.4,-0.15) node[below] { $iT$};
< \draw[thin] (3,0.82) -- (3,-0.15) node[below] { $(i+1)T$};
< 
< \draw[->,thick] (-0.1,0.55) -- node[above,xshift=7ex] {$s,\; a$} (1.55,0.55);
< \draw[<-,thick] (1.55,0.55) -- node[above,xshift=-6ex] {$s',\; a'$} (3.2,0.55);
< 
< \begin{scope}[font=\scriptsize]
< \draw[dashed] (0,0.8) node[above] {$\star$} -- (0,-0.01) node[below] {$iT - \epsilon$} ;
< \draw[dashed] (0.8,0.8) -- (0.8,-0.01) node[below] {$iT + \epsilon$};
< \draw[dotted,thick] (1.7,0.8) -- (1.7,-0.01) node[below] {$iT + \epsilon + \alpha_M$};
< \draw[dashed] (2.6,0.8) node[above] {$\star$}  -- (2.6,-0.01) node[below] { $(i+1)T - \epsilon$};
< 
< \draw[<-,densely dotted,semithick] (0.26,0.27) -- (0.26,0.84) node[above] {$c_M(i)$};
< \draw[<-,densely dotted,semithick] (0.72,0.38) -- (0.72,0.84) node[above] {$c_M(i) + t_I$};
< \draw[<-,densely dotted,semithick] (1.55,0.42) -- (1.55,0.84) node[above] {$c_M(i) + t_R$};
< \end{scope}
< 
< \filldraw (0,0.15) circle (0.5pt) node[above,xshift=-1.2ex] {$\vec{v}$};
< \filldraw (0.26,0.24) circle (0.5pt);
< \filldraw (0.72,0.35) circle (0.5pt) node[below] {$\vec{v}_I$};
< \filldraw (1.55,0.39) circle (0.5pt) node[below] {$\vec{v}_R$};
< \filldraw (2.6,0.235) circle (0.5pt) node[below,xshift=1.2ex] {$\vec{v'}$};
< \draw (-0.1,0.11) .. controls (1.6,0.8) and (2.3,0.0) .. (3.2,0.3);
< \end{tikzpicture}
< \caption{Timeline for an environment-restricted controller $M \restriction E_M$
< with a local clock $c_M$, an environment sampling time $t_I$, and an response time $t_R$.}
< \label{fig:env-restriction}
< \end{figure}
< 
< 
< 
< Fig.~\ref{fig:env-restriction} depicts the behavior of 
< the \emph{environment restriction} $M \restriction E_M$ %of  $M$ by   $E_M$ 
< in a PALS distributed model. % $\mathcal{MA}(\mathcal{E},T,\Gamma)$.
< Its $(i+1)$-th period begins  at time $c_M(i) \in (i T - \epsilon, i T + \epsilon)$. 
< % according to its local clock $c_M$.
< As explained in Section~\ref{pals-dist}, $M$ has already received all the inputs $\vec{i}$ %for this round 
< before time $i T - \epsilon$.  At this time, $M$ also samples the
< appropriate values of its environment $E_M$. The sampling takes time
< $t_I$, so that 
< the physical state $\vec{v}_I$ of $E_M$ is read at time $c_M(i) + t_I$.
< $M$ executes its transition based on the inputs $\vec{i}$, the %sampled 
< physical state $\vec{v}_I$,  and the current 
< machine state $s$.
< %
< After the execution ends,
< the machine state changes to  $s'$, and the new controller command $a$
< is sent to $E_M$  at time  $c_M(i) + t_R$, %where it is treated immediately.
< where $t_R$ denotes the response time, 
< which equals the transition execution time and the actuator processing time.
< The new outputs $\vec{o}$ from $M$ are delivered to their destinations
< before time $(i+1) T - \epsilon$.
< %footnote{KYUNGMIN:  this last sentence is my understanding; is it correct?  We need to
< %  explain clearly exactly when sampling and actuating take place, and  that's what I have tried.}
< 
< 
< 
< 
< %We assume that 
< A control command from a controller $M$ depends on $M$'s current  state.
< In Fig.~\ref{fig:env-restriction}, a current control command $a$ % (given by $s$)
< remains effective 
< until the execution ends at time $c_M(i) + t_R$,
< and then a new control command $a'$ % (given by $s'$)
< takes effect.
< A physical environment 
< $E_M$ defines trajectories of its parameters $\vec{x}$:
< \begin{inparaenum}[(i)]
<     \item from state $\vec{v}$ to $\vec{v}_I$ for the interval $[iT - \epsilon, c_M(i) + t_I]$ by the current command $a$,
<     \item from $\vec{v}_I$ to $\vec{v}_R$ for the interval $[c_M(i) + t_I, c_M(i) + t_R]$ by again $a$, and 
<     \item from $\vec{v}_R$ to $\vec{v'}$ for $[c_M(i) + t_R, (i+1)T-\epsilon]$ by the new control command $a'$.
< \end{inparaenum}
< Notice that $0 \leq t_I \leq t_R \leq \alpha_M$ for the maximal execution time $\alpha_M$  of $M$.
< As a result,
< a \emph{big step} transition of $M \restriction E_M$ from state $(s, \vec{v})$ with input $\vec{i}$ 
< to state $(s',\vec{v'})$ with output $\vec{o}$
< is defined for the time interval $[iT - \epsilon, (i+1)T-\epsilon]$ in \emph{distributed PALS models}.
< 
< % Moreover, $M \restriction E_M$ 
< % can be considered as a ``normal'' state machine
< % in \emph{synchronous models},
< % provided that the timing values (such as $c_M(i)$, $t_I$, and $t_R$)
< % as well as control commands are  determined by $M$'s machine states
< % and inputs.\footnote{KYUNGMIN:  This last paragraph seems a little
< %   unmotivated and misplaced here; can it be dropped?  Instead, it
< %   would be MUCH better to informally introduce ``interfaces'' before
< %   giving the definition ...}
< 
< A machine $M$ that integrates both a controller and its environment
< should have a state space of the form $S\times \mathbb{R}^m$,  where
< $\mathbb{R}^m$ is the state space of the $m$ physical parameters that
< $M$ observes.   That $M$ has a transition for \emph{any} environment
< values follows directly from the definitions of machines: their
< transition relations are total. To compose such a machine with its
< environment, we must define the ``interface'' between the controller
< part and the ``environment part'' of such an environment-parametric
< machine $M$. This interface is given by the following projection functions:
< 
< 
< \begin{definition}
< \label{def:env-interface}
< % Suppose that $M$ has a state space of the form
< % $S\times \mathbb{R}^m$  for $\mathbb{R}^m$ the $m$ physical parameters that $M$ observes.   
< % For $(s,\vec{v}_o) \in S \times \mathbb{R}^m$,
< The \emph{interface} of a controller $M$ is given by the %following
< projection functions $\pi=(\pi_T, \pi_R, \pi_I, \pi_C, \pi_O)$, where $s\in S$ is a state in $M$: 
< \begin{inparaenum}[(i)]
<         \item $\pi_T(s) \in \mathbb{N}$ a ``round'' number; 
<         %(i.e., $\pi_T(s) = i$ means that the next iteration of the system is iteration $i$); 
<         \item $\pi_R(s,\vec{i}) \in \mathbb{R}$ a %environment 
<         response time;
<         \item $\pi_I(s) \in \mathbb{R}$ a %environment 
<         sampling time;
<         and    
<         \item $\pi_C(s) \in C$ the control command of $M$  to $E_M$.
< \end{inparaenum}
< For state $\vec{v} \in \mathbb{R}^l$ of $E_M$,  
< the \emph{observable} part of $\vec{v}$ by $M$
< is given by the projection function 
< $\pi_O(\vec{v}) \in \mathbb{R}^{m}$.
< \end{definition}
< 
< The environment restriction of $M$ can then be defined in the expected way:
< % Given state $(s, \vec{v})$ and input $\vec{i}$,
< % the next state $(s', \vec{v'})$ and output $\vec{o}$ can be constructed %using $M$ and $E_M$
< % by the same process of Fig.~\ref{fig:env-restriction}:
< 
< \begin{definition}
< \label{def:env-res}
< The \emph{environment restriction} of $M$ by $E_M$ 
< with an interface $\pi$ is %the machine
< $M \restriction_\pi E_M = (D_i, S \times \mathbb{R}^l, D_o, \delta_{M \restriction_\pi E_M})$,
< where
< $( (\vec{i}, (s,\vec{v})), ((s',\vec{v'}), \vec{o}) ) \in \delta_{M \restriction_\pi E_M}$ holds iff
<  $\pi_T(s') = i + 1$ for the round number $i = \pi_T(s)$, and:
< \begin{enumerate}
<     \item %(Sampling) 
<     $((a,u_I,\vec{v}),\tau_I) \in \Lambda$ and $\vec{v}_I = \tau_I(u_I)$,
<     for  $t_I = \pi_I(s)$, duration $u_I = (c_M(i)+t_I)-(iT-\epsilon)$, and
<     the current controller command $a = \pi_C(s)$;
< 
<     \item %(Execution) 
<     $((a,u_R-u_I,\vec{v}_I),\tau_R) \in \Lambda$ and $\vec{v}_R = \tau_R(u_R-u_I)$,
<     for $t_R = \pi_R(s,\vec{i})$ and $u_R = (c_M(i)+t_R) - (iT-\epsilon)$;
< 
<     \item %(Transition) 
<     $( (\vec{i}, (s,\pi_O(\vec{v}_I))), ((s',\pi_O(\vec{v'})), \vec{o}) ) \in \delta_{M}$; and
<     
<     \item %(Waiting) 
<     $((a',T - u_R,\vec{v}_R),\tau_W) \in \Lambda$ and  $\vec{v'} = \tau_W(T - u_R)$,
<     for the next control command $a' = \pi_C(s')$.
< \end{enumerate}
< \end{definition}
< 
< 
< 
< \subsection{Hybrid PALS}
< 
< Hybrid PALS models are parameterized by \emph{sampling and response timing policies}
< that 
< determine sensor sampling timing $t_I$ and actuator response timing $t_R$.
< %besides  bounds $\Gamma$.
< Such a policy 
< is given as a collection of 
< projection functions $\pi=(\pi_T, \pi_R, \pi_I, \pi_C, \pi_O)$ 
< in Definition~\ref{def:env-interface}.
< The continuous dynamics %of a PALS system 
< is ``completely'' decided  
< by the controllers,  % (in $\mathcal{E}$ or $\mathcal{MA}(\mathcal{E},T,\Gamma)$),
< their physical environments, and timing policies (including local clocks of controllers). 
< %  \textbf{(Peter)  Are the clock functions also parameters, or are we quantifying over
< %  all local clock skews??}
< %
< %
< % Deciding $\pi$ is a design choice. 
< % Most generally, values of $\pi$ can vary
< % according to states and inputs.
< % More realistically, sampling/response timings are fixed 
< % to certain numbers to simplify the system complicity.
< In % our previous work
< \cite{hybrid-pals}, $t_I$ is $0$ 
< (for controllers tightly integrated with their environments)
< and $t_R$ is  
< the maximum execution time $\alpha_{\max}$.
< 
< 
< The synchronous model in Hybrid PALS is specified
< as a multirate ensemble $\mathcal{E}$ and  the physical environments of subcomponents,
< where physical correlations between those environments
< are specified as time-invariant constraints.
< 
< \begin{definition}
< A \emph{hybrid multirate ensemble} $\mathcal{E}\restriction_{\Pi} E_{\mathcal{E}}$
< is given by:
< \begin{inparaenum}[(i)]
<     \item a multirate ensemble $\mathcal{E}$, %= (J_S ,  J_F, e, \{M_j\}_{j\in J_S \cup J_F}, E, \mathit{src}, \mathit{rate}, \mathit{adap})$ 
<     \item a family of policy functions $\Pi=\{\pi_j\}_{j\in J_S  \cup J_F}$
<     (with $J_S$ an index set of slow machines and $J_F$ an index set of fast machines),
<     and
<     \item a family of local physical environments 
<     $E_\mathcal{E} = \langle\{E_{M_j}\}_{j\in J_S \cup J_F}, \forall t.\, \psi)\rangle$ 
<     with $\forall t.\,\psi$ the time-invariant constraints.
< \end{inparaenum}
< \end{definition}   
< 
< 
< The behaviors of a hybrid ensemble  $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$
< are  a \emph{subset} of the behaviors of $\mathcal{E}$, namely, the behaviors restricted by 
< the physical environment $E_\mathcal{E}$.
< As mentioned,
< each (decelerated) environment-restricted machine $M_j \restriction_\pi E_{M_j}$ defines 
< a transition from a state  at time $iT - \epsilon$ to one at time $(i+1)T-\epsilon$ for a global period $T$.
< Therefore, a lockstep composition of such %environment-restricted 
< transitions
< \emph{that also satisfies the time-invariant constraints} gives a transition of 
< the synchronous composition $M_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}$
< from one state at time $iT - \epsilon$ to another state at time $(i+1)T-\epsilon$.
< 
< 
< Hybrid PALS maps a hybrid multirate ensemble
< $\mathcal{E}\restriction_{\Pi} E_\mathcal{E}$ with a global period $T$, 
< together with PALS bounds $\Gamma$,  to the distributed hybrid system  
< $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$.
< Similarly, its  behaviors are the subset of those of the %PALS
< distributed system $\mathcal{MA}(\mathcal{E}, T, \Gamma)$ that can be realized
< by the %physical 
< environment $E_\mathcal{E}$
< and satisfy the time-invariant constraints.
< In particular, big-step transitions of each component $M_j \restriction_\pi E_{M_j}$ are
< defined for the interval $[iT - \epsilon, (i+1)T-\epsilon]$
<  as explained in Section~\ref{sec:env-res}.
< 
< 
< The correctness of Hybrid PALS follows from the fact that 
< all physical measurements and physical activation \emph{happen at the same time}
< in both $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$  and $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$ with the \emph{same timing policies} $\Pi$.
< %(see Definition~\ref{def:env-res}).
< %
< Recall that stable states of $\mathcal{MA}(\mathcal{E}, T, \Gamma)$ are states at times $iT - \epsilon$.
< Hence,  big-step ``stable'' transitions are well defined for 
< $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$
< from $iT - \epsilon$ to $(i+1)T-\epsilon$,
< which are exactly related to single steps of the synchronous composition 
< $M_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}$ (by the same relation $(\sim_\mathit{obi} \,;\, \mathit{sync})$ in Theorem~\ref{thm:mr-pals}).
< Consequently, we have:
< 
< 
< \begin{theorem}\label{thm:hybrid-pals} 
< The relation $(\sim_\mathit{obi} \,;\, \mathit{sync})$ 
< is a bisimulation between 
< the transition system by $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$ 
< and the big-step stable transition system induced by $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$.
< \end{theorem}
< 
< 
< 
< 
< 
---
> % !TEX root = /Users/kquine/Dropbox/Research/Papers/2015/CPS-SMT-RTSS/cps-rtss.tex
> 
> \section{Hybrid PALS}
> \label{sec:hybrid-pals}
> 
> 
> %\textbf{(Peter) Some very important overview text added!}
> 
> This section presents \emph{Hybrid PALS}, which extends PALS to hybrid
> systems.  One main difference between PALS and Hybrid PALS is that
>  the time at which an event takes place does not matter in PALS, as
> long as it happens within a certain time interval. This
>  allows us to relate a distributed
> real-time system to an essentially untimed synchronous model. However,
> in hybrid systems, we cannot abstract from the time at which a
> continuous value is read or  an actuator command is given
> (both of which depend on a component's imprecise local clock). Therefore,
> the precise times at which these events happen must be included also
> in the \emph{synchronous} Hybrid PALS models to have any possibility
> of an equivalence between the synchronous model and the distributed
> hybrid system. 
> 
> 
> In Hybrid PALS, a  state of a physical environment %of a machine $M$ 
> is 
> a tuple $\vec{v} = (v_1,\ldots,v_l) \in \mathbb{R}^l$ 
> of its physical parameters $\vec{x} = (x_1, \ldots,x_l)$,
> and
> the behavior of %the physical parameters 
> $\vec{x}$
> can be modeled by ODEs that specify \emph{trajectories} 
> $\tau_1, \ldots, \tau_l$ of %the parameters 
> $\vec{x}$ over time.
> %
> %The continuous dynamics %of the system 
> %is specified by \emph{controlled physical environments} $E$.
> The standard PALS models $\mathcal{E}$ and $\mathcal{MA}(\mathcal{E},T,\Gamma)$ 
> are  nondeterministic models defined for \emph{any possible} environment behaviors.
> The \emph{environment restrictions} 
> $\mathcal{MA}(\mathcal{E},T,\Gamma)\restriction E$
> and
> $\mathcal{E} \restriction E$
> %introduced in~\cite{hybrid-pals}, 
>  define the behavior of the models 
>  constrained by the physical  environment $E$.  To have any
>  control over when values are read from, and sent to, physical environments, we add in this paper \emph{sampling and
>    response timing policies} to the Hybrid PALS models. 
> We then  
> prove a bisimulation equivalence 
> relating $\mathcal{E}\restriction E$ and $\mathcal{MA}(\mathcal{E}, T,\Gamma)\restriction E$,
> %with respect to physical environments,
> which generalizes the  trace equivalence result in \cite{hybrid-pals}.
> 
> 
> 
> \subsection{Controlled Physical Environments}
> 
> %Let $\vec{\tau}(t) = (\tau_1(t),\ldots,\tau_l(t))$
> %for an l-tuple of trajectories 
> %$\vec{\tau} = (\tau_1,\ldots,\tau_l)$.
> %Notice that the parameters $\vec{x}$ are also trajectories
> %in such a way that a state of  the physical environment at time $t$
> 
> 
> A (local)  %physical 
> environment $E_M$ of machine $M$
> is specified as a   \emph{controlled physical environment}
> that defines every possible trajectory of its physical parameters %$\vec{x}$
> for the control commands from $M$.
> %
> For a state $\vec{v} \in \mathbb{R}^l$, a control command $a$, and a duration $t \in \mathbb{R}$,
> a %controlled 
> physical environment $E_M$
> gives a trajectory $\vec{\tau}$ of its parameters $\vec{x}$ of duration $t$,
> as illustrated in Fig.~\ref{fig:physical-transition}.
> %(e.g., state $v_1$, command $a$, duration $t_2-t_1$ yields trajectory $\tau_1$).
> 
> \begin{definition}
> Let  $\mathcal{T}$ denote the set of all
> trajectories (a trajectory of duration $T$ is a function $\tau : [0,T] \rightarrow \mathbb{R}$).
> A \emph{controlled physical environment} $E_M = (C, \vec{x}, \Lambda)$ consists of:
> \begin{inparaenum}[(i)]
>     \item $C$ a set of \emph{control commands}; %(or ``actuator outputs'') from  $M$;
>     \item $\vec{x} = (x_1, \ldots,x_l)$ a vector of real number variables; and
>     \item $\Lambda \subseteq (C \times \mathbb{R}_{\geq 0} \times \mathbb{R}^l) \times \mathcal{T}^l$
>     a \emph{physical transition relation}, where
>     $((a, t, \vec{v}),  \vec{\tau}) \in \Lambda$
>     iff for a control command $a \in C$ that lasts 
>     for duration~$t$, 
>     $E_M$'s physical state $\vec{x}$ follows the trajectory 
>     $\vec{\tau} \in \mathcal{T}^l$
>     from $\vec{v} \in \mathbb{R}^l$ with
>         $\vec{\tau}(0) = \vec{v}$.
> \end{inparaenum}
> (E.g., $((a_1,t_2-t_1,v_1), \tau_1) \in \Lambda$ in Fig.~\ref{fig:physical-transition}).
> \end{definition}
> 
> \begin{figure}
> \centering
> \begin{tikzpicture}[xscale=2.5,yscale=1.39,font=\footnotesize]
> %baseline
> \draw[-latex,thin] (-0.1,0) -- (3.2,0);
> \draw[shift={(0,0)},thin,dashed] (0,1.1) -- (0,-0.05) node[below] {\footnotesize $t_0$};
> \draw[shift={(0.7,0)},thin,dashed] (0,1.1) -- (0,-0.05) node[below] {\footnotesize $t_1$};
> \draw[shift={(2.1,0)},thin,dashed] (0,1.1) -- (0,-0.05) node[below] {\footnotesize $t_2$};
> \draw[shift={(3,0)},thin,dashed] (0,1.1) -- (0,-0.05) node[below] {\footnotesize $t_3$};
> %curves
> \begin{scope}[yshift=6pt]
> \filldraw (0,0.21) circle (0.5pt) node[below,xshift=-1.2ex] {$v_0$};
> \draw (0,0.21) .. controls (0.3,0.15) and (0.4,0.5) .. node[above,sloped] (t0) {$\tau_0$} (0.7,0.35);
> \draw[-open triangle 45,very thin] ($(t0.north) + (-0.1,0.15)$) node[above] {$a_0$} -- ($(t0.north) + (-0.02,0.02)$);
>     \filldraw (0.7,0.35) circle (0.5pt) node[below,xshift=-1.2ex] {$v_1$};
>     \draw (0.7,0.35) .. controls (1.3,0.25) and (1.6,0.4) .. node[above,sloped] (t1) {$\tau_1$} (2.1,0.6);
>     \draw[-open triangle 45,very thin] ($(t1.north) + (-0.2,0.15)$) node[left,yshift=2pt] {$a_1$} -- ($(t1.north) + (-0.02,0.02)$);
> 	\filldraw (2.1,0.6) circle (0.5pt) node[above,xshift=-1.2ex] {$v_2$};
> 	\draw (2.1,0.6) .. controls (2.6,0.7) and (2.7,0.7) .. node[above,sloped] (t2) {$\tau_2$} (3,0.77);
> 	\draw[-open triangle 45,very thin] ($(t2.west) + (-0.15,0.05)$) node[left,yshift=1pt] {$a_2$} -- ($(t2.west) + (-0.02,0.01)$);
> 	    \filldraw (3,0.77) circle (0.5pt) node[right,yshift=1ex] {$v_3$};
> 	\draw (2.1,0.6) .. controls (2.6,0.7) and (2.7,0.4) .. node[below,sloped] (t2') {$\tau_2'$} (3,0.57);
> 	    \filldraw (3,0.57) circle (0.5pt) node[right,yshift=-0.2ex] {$v_3'$};
> 	\draw[-open triangle 45,very thin] ($(t2'.west) + (-0.15,-0.1)$) node[left,yshift=-1pt] {$a_2'$} -- ($(t2'.west) + (-0.02,-0.02)$);
> 
>     \draw (0.7,0.35) .. controls (1.3,0.15) and (1.6,0.5) .. node[below,sloped] (t1') {$\tau_1'$} (2.1,0.1);
>     \draw[-open triangle 45,very thin] ($(t1'.south) + (-0.2,-0.15)$) node[left,yshift=-2pt] {$a_1'$} -- ($(t1'.south) + (-0.02,-0.02)$);
> 	\filldraw (2.1,0.1) circle (0.5pt) node[below,xshift=-1.5ex] {$v_2'$};
> 	\draw (2.1,0.1) .. controls (2.6,-0.1) and (2.7,0.3) .. node[below,sloped] (t2''){$\tau_2''$} (3,0.2);
> 	\draw[-open triangle 45,very thin] ($(t2''.west) + (-0.15,-0.05)$) node[left,yshift=-1pt] {$a_2''$} -- ($(t2''.west) + (-0.02,-0.02)$);
> 	    \filldraw (3,0.2) circle (0.5pt) node[right,yshift=-1.5ex] {$v_3''$};;;
> \end{scope}
> \end{tikzpicture}
> \caption{A controlled physical environment $E_M$.}
> \label{fig:physical-transition}
> \end{figure}
> 
> 
> Several physical environments may be physically correlated,
> and one %local 
> environment may % immediately
> affect  another environment.
> Such %physical 
> correlations are %naturally 
> expressed as
> \emph{time-invariant constraints} $(\forall t.\, \psi)$ of physical parameters over time $t$.
> %(e.g., some parameter of one physical environment should always 
> %  equal some other  parameter of another physical environment).
> For example, if %physical 
> parameter $x_1$ of $E_{M_1}$
> must be equal to  parameter $x_2$ of %another environment 
> $E_{M_2}$,
> then the time-invariant constraint is  %the formula
> $\forall t.\; x_1(t) = x_2(t)$.
> %\footnote{Without loss of generality, we assume that different parameter names of different components are all different.}
> %with variable $t$ for time.
> 
> 
> 
> 
> \subsection{Environment-Restricted Controllers}
> \label{sec:env-res}
> 
> A controller $M$ is a \emph{nondeterministic} machine
> parameterized by any behavior of its %physical 
> environment $E_M$.
> %
> The controller 
> $M$ interacts  with %its physical environment 
> $E_M$
> according to its local clock,
> which may  differ from global time by up to  
> the maximal clock skew $\epsilon$.
> Let $c_M : \mathbb{N} \to \mathbb{R}_{>0}$ denote a a \emph{periodic local clock} of $M$
> that gives the \emph{global time} at the
> beginning of the $(i+1)$-th period according to $M$'s local clock. 
> That is,  $c_M(0) = 0$
> and
> $c_M(n) \in (n T - \epsilon, n T + \epsilon)$ for each $n > 0$.
> 
> 
> 
> \begin{figure}
> \centering
> \begin{tikzpicture}[xscale=2.5,yscale=1.68,font=\footnotesize]
> %baseline
> \draw[-latex,thin] (-0.2,0) -- (3.3,0);
> \draw[-latex,thin] (-0.2,0.8) -- (3.3,0.8);
> 
> \draw[thin] (0.4,0.82) -- (0.4,-0.15) node[below] { $iT$};
> \draw[thin] (3,0.82) -- (3,-0.15) node[below] { $(i+1)T$};
> 
> \draw[->,thick] (-0.1,0.55) -- node[above,xshift=7ex] {$s,\; a$} (1.55,0.55);
> \draw[<-,thick] (1.55,0.55) -- node[above,xshift=-6ex] {$s',\; a'$} (3.2,0.55);
> 
> \begin{scope}[font=\scriptsize]
> \draw[dashed] (0,0.8) node[above] {$\star$} -- (0,-0.01) node[below] {$iT - \epsilon$} ;
> \draw[dashed] (0.8,0.8) -- (0.8,-0.01) node[below] {$iT + \epsilon$};
> \draw[dotted,thick] (1.7,0.8) -- (1.7,-0.01) node[below] {$iT + \epsilon + \alpha_M$};
> \draw[dashed] (2.6,0.8) node[above] {$\star$}  -- (2.6,-0.01) node[below] { $(i+1)T - \epsilon$};
> 
> \draw[<-,densely dotted,semithick] (0.26,0.27) -- (0.26,0.84) node[above] {$c_M(i)$};
> \draw[<-,densely dotted,semithick] (0.72,0.38) -- (0.72,0.84) node[above] {$c_M(i) + t_I$};
> \draw[<-,densely dotted,semithick] (1.55,0.42) -- (1.55,0.84) node[above] {$c_M(i) + t_R$};
> \end{scope}
> 
> \filldraw (0,0.15) circle (0.5pt) node[above,xshift=-1.2ex] {$\vec{v}$};
> \filldraw (0.26,0.24) circle (0.5pt);
> \filldraw (0.72,0.35) circle (0.5pt) node[below] {$\vec{v}_I$};
> \filldraw (1.55,0.39) circle (0.5pt) node[below] {$\vec{v}_R$};
> \filldraw (2.6,0.235) circle (0.5pt) node[below,xshift=1.2ex] {$\vec{v'}$};
> \draw (-0.1,0.11) .. controls (1.6,0.8) and (2.3,0.0) .. (3.2,0.3);
> \end{tikzpicture}
> \caption{Timeline for an environment-restricted controller $M \restriction E_M$
> with a local clock $c_M$, an environment sampling time $t_I$, and an response time $t_R$.}
> \label{fig:env-restriction}
> \end{figure}
> 
> 
> 
> Fig.~\ref{fig:env-restriction} depicts the behavior of 
> the \emph{environment restriction} $M \restriction E_M$ %of  $M$ by   $E_M$ 
> in a PALS distributed model. % $\mathcal{MA}(\mathcal{E},T,\Gamma)$.
> Its $(i+1)$-th period begins  at time $c_M(i) \in (i T - \epsilon, i T + \epsilon)$. 
> % according to its local clock $c_M$.
> As explained in Section~\ref{pals-dist}, $M$ has already received all the inputs $\vec{i}$ %for this round 
> before time $i T - \epsilon$.  At this time, $M$ also samples the
> appropriate values of its environment $E_M$. The sampling takes time
> $t_I$, so that 
> the physical state $\vec{v}_I$ of $E_M$ is read at time $c_M(i) + t_I$.
> $M$ executes its transition based on the inputs $\vec{i}$, the %sampled 
> physical state $\vec{v}_I$,  and the current 
> machine state $s$.
> %
> After the execution ends,
> the machine state changes to  $s'$, and the new controller command $a$
> is sent to $E_M$  at time  $c_M(i) + t_R$, %where it is treated immediately.
> where $t_R$ denotes the response time, 
> which equals the transition execution time and the actuator processing time.
> The new outputs $\vec{o}$ from $M$ are delivered to their destinations
> before time $(i+1) T - \epsilon$.
> %footnote{KYUNGMIN:  this last sentence is my understanding; is it correct?  We need to
> %  explain clearly exactly when sampling and actuating take place, and  that's what I have tried.}
> 
> 
> 
> 
> %We assume that 
> A control command from a controller $M$ depends on $M$'s current  state.
> In Fig.~\ref{fig:env-restriction}, a current control command $a$ % (given by $s$)
> remains effective 
> until the execution ends at time $c_M(i) + t_R$,
> and then a new control command $a'$ % (given by $s'$)
> takes effect.
> A physical environment 
> $E_M$ defines trajectories of its parameters $\vec{x}$:
> \begin{inparaenum}[(i)]
>     \item from state $\vec{v}$ to $\vec{v}_I$ for the interval $[iT - \epsilon, c_M(i) + t_I]$ by the current command $a$,
>     \item from $\vec{v}_I$ to $\vec{v}_R$ for the interval $[c_M(i) + t_I, c_M(i) + t_R]$ by again $a$, and 
>     \item from $\vec{v}_R$ to $\vec{v'}$ for $[c_M(i) + t_R, (i+1)T-\epsilon]$ by the new control command $a'$.
> \end{inparaenum}
> Notice that $0 \leq t_I \leq t_R \leq \alpha_M$ for the maximal execution time $\alpha_M$  of $M$.
> As a result,
> a \emph{big step} transition of $M \restriction E_M$ from state $(s, \vec{v})$ with input $\vec{i}$ 
> to state $(s',\vec{v'})$ with output $\vec{o}$
> is defined for the time interval $[iT - \epsilon, (i+1)T-\epsilon]$ in \emph{distributed PALS models}.
> 
> % Moreover, $M \restriction E_M$ 
> % can be considered as a ``normal'' state machine
> % in \emph{synchronous models},
> % provided that the timing values (such as $c_M(i)$, $t_I$, and $t_R$)
> % as well as control commands are  determined by $M$'s machine states
> % and inputs.\footnote{KYUNGMIN:  This last paragraph seems a little
> %   unmotivated and misplaced here; can it be dropped?  Instead, it
> %   would be MUCH better to informally introduce ``interfaces'' before
> %   giving the definition ...}
> 
> A machine $M$ that integrates both a controller and its environment
> should have a state space of the form $S\times \mathbb{R}^m$,  where
> $\mathbb{R}^m$ is the state space of the $m$ physical parameters that
> $M$ observes.   That $M$ has a transition for \emph{any} environment
> values follows directly from the definitions of machines: their
> transition relations are total. To compose such a machine with its
> environment, we must define the ``interface'' between the controller
> part and the ``environment part'' of such an environment-parametric
> machine $M$. This interface is given by the following projection functions:
> 
> 
> \begin{definition}
> \label{def:env-interface}
> % Suppose that $M$ has a state space of the form
> % $S\times \mathbb{R}^m$  for $\mathbb{R}^m$ the $m$ physical parameters that $M$ observes.   
> % For $(s,\vec{v}_o) \in S \times \mathbb{R}^m$,
> The \emph{interface} of a controller $M$ is given by the %following
> projection functions $\pi=(\pi_T, \pi_R, \pi_I, \pi_C, \pi_O)$, where $s\in S$ is a state in $M$: 
> \begin{inparaenum}[(i)]
>         \item $\pi_T(s) \in \mathbb{N}$ a ``round'' number; 
>         %(i.e., $\pi_T(s) = i$ means that the next iteration of the system is iteration $i$); 
>         \item $\pi_R(s,\vec{i}) \in \mathbb{R}$ a %environment 
>         response time;
>         \item $\pi_I(s) \in \mathbb{R}$ a %environment 
>         sampling time;
>         and    
>         \item $\pi_C(s) \in C$ the control command of $M$  to $E_M$.
> \end{inparaenum}
> For state $\vec{v} \in \mathbb{R}^l$ of $E_M$,  
> the \emph{observable} part of $\vec{v}$ by $M$
> is given by the projection function 
> $\pi_O(\vec{v}) \in \mathbb{R}^{m}$.
> \end{definition}
> 
> The environment restriction of $M$ can then be defined in the expected way:
> % Given state $(s, \vec{v})$ and input $\vec{i}$,
> % the next state $(s', \vec{v'})$ and output $\vec{o}$ can be constructed %using $M$ and $E_M$
> % by the same process of Fig.~\ref{fig:env-restriction}:
> 
> \begin{definition}
> \label{def:env-res}
> The \emph{environment restriction} of $M$ by $E_M$ 
> with an interface $\pi$ is %the machine
> $M \restriction_\pi E_M = (D_i, S \times \mathbb{R}^l, D_o, \delta_{M \restriction_\pi E_M})$,
> where
> $( (\vec{i}, (s,\vec{v})), ((s',\vec{v'}), \vec{o}) ) \in \delta_{M \restriction_\pi E_M}$ holds iff
>  $\pi_T(s') = i + 1$ for the round number $i = \pi_T(s)$, and:
> \begin{enumerate}
>     \item %(Sampling) 
>     $((a,u_I,\vec{v}),\tau_I) \in \Lambda$ and $\vec{v}_I = \tau_I(u_I)$,
>     for  $t_I = \pi_I(s)$, duration $u_I = (c_M(i)+t_I)-(iT-\epsilon)$, and
>     the current controller command $a = \pi_C(s)$;
> 
>     \item %(Execution) 
>     $((a,u_R-u_I,\vec{v}_I),\tau_R) \in \Lambda$ and $\vec{v}_R = \tau_R(u_R-u_I)$,
>     for $t_R = \pi_R(s,\vec{i})$ and $u_R = (c_M(i)+t_R) - (iT-\epsilon)$;
> 
>     \item %(Transition) 
>     $( (\vec{i}, (s,\pi_O(\vec{v}_I))), ((s',\pi_O(\vec{v'})), \vec{o}) ) \in \delta_{M}$; and
>     
>     \item %(Waiting) 
>     $((a',T - u_R,\vec{v}_R),\tau_W) \in \Lambda$ and  $\vec{v'} = \tau_W(T - u_R)$,
>     for the next control command $a' = \pi_C(s')$.
> \end{enumerate}
> \end{definition}
> 
> 
> 
> \subsection{Hybrid PALS}
> 
> Hybrid PALS models are parameterized by \emph{sampling and response timing policies}
> that 
> determine sensor sampling timing $t_I$ and actuator response timing $t_R$.
> %besides  bounds $\Gamma$.
> Such a policy 
> is given as a collection of 
> projection functions $\pi=(\pi_T, \pi_R, \pi_I, \pi_C, \pi_O)$ 
> in Definition~\ref{def:env-interface}.
> The continuous dynamics %of a PALS system 
> is ``completely'' decided  
> by the controllers,  % (in $\mathcal{E}$ or $\mathcal{MA}(\mathcal{E},T,\Gamma)$),
> their physical environments, and timing policies (including local clocks of controllers). 
> %  \textbf{(Peter)  Are the clock functions also parameters, or are we quantifying over
> %  all local clock skews??}
> %
> %
> % Deciding $\pi$ is a design choice. 
> % Most generally, values of $\pi$ can vary
> % according to states and inputs.
> % More realistically, sampling/response timings are fixed 
> % to certain numbers to simplify the system complicity.
> In % our previous work
> \cite{hybrid-pals}, $t_I$ is $0$ 
> (for controllers tightly integrated with their environments)
> and $t_R$ is  
> the maximum execution time $\alpha_{\max}$.
> 
> 
> The synchronous model in Hybrid PALS is specified
> as a multirate ensemble $\mathcal{E}$ and  the physical environments of subcomponents,
> where physical correlations between those environments
> are specified as time-invariant constraints.
> 
> \begin{definition}
> A \emph{hybrid multirate ensemble} $\mathcal{E}\restriction_{\Pi} E_{\mathcal{E}}$
> is given by:
> \begin{inparaenum}[(i)]
>     \item a multirate ensemble $\mathcal{E}$, %= (J_S ,  J_F, e, \{M_j\}_{j\in J_S \cup J_F}, E, \mathit{src}, \mathit{rate}, \mathit{adap})$ 
>     \item a family of policy functions $\Pi=\{\pi_j\}_{j\in J_S  \cup J_F}$
>     (with $J_S$ an index set of slow machines and $J_F$ an index set of fast machines),
>     and
>     \item a family of local physical environments 
>     $E_\mathcal{E} = \langle\{E_{M_j}\}_{j\in J_S \cup J_F}, \forall t.\, \psi)\rangle$ 
>     with $\forall t.\,\psi$ the time-invariant constraints.
> \end{inparaenum}
> \end{definition}   
> 
> 
> The behaviors of a hybrid ensemble  $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$
> are  a \emph{subset} of the behaviors of $\mathcal{E}$, namely, the behaviors restricted by 
> the physical environment $E_\mathcal{E}$.
> As mentioned,
> each (decelerated) environment-restricted machine $M_j \restriction_\pi E_{M_j}$ defines 
> a transition from a state  at time $iT - \epsilon$ to one at time $(i+1)T-\epsilon$ for a global period $T$.
> Therefore, a lockstep composition of such %environment-restricted 
> transitions
> \emph{that also satisfies the time-invariant constraints} gives a transition of 
> the synchronous composition $M_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}$
> from one state at time $iT - \epsilon$ to another state at time $(i+1)T-\epsilon$.
> 
> 
> Hybrid PALS maps a hybrid multirate ensemble
> $\mathcal{E}\restriction_{\Pi} E_\mathcal{E}$ with a global period $T$, 
> together with PALS bounds $\Gamma$,  to the distributed hybrid system  
> $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$.
> Similarly, its  behaviors are the subset of those of the %PALS
> distributed system $\mathcal{MA}(\mathcal{E}, T, \Gamma)$ that can be realized
> by the %physical 
> environment $E_\mathcal{E}$
> and satisfy the time-invariant constraints.
> In particular, big-step transitions of each component $M_j \restriction_\pi E_{M_j}$ are
> defined for the interval $[iT - \epsilon, (i+1)T-\epsilon]$
>  as explained in Section~\ref{sec:env-res}.
> 
> 
> The correctness of Hybrid PALS follows from the fact that 
> all physical measurements and physical activation \emph{happen at the same time}
> in both $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$  and $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$ with the \emph{same timing policies} $\Pi$.
> %(see Definition~\ref{def:env-res}).
> %
> Recall that stable states of $\mathcal{MA}(\mathcal{E}, T, \Gamma)$ are states at times $iT - \epsilon$.
> Hence,  big-step ``stable'' transitions are well defined for 
> $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$
> from $iT - \epsilon$ to $(i+1)T-\epsilon$,
> which are exactly related to single steps of the synchronous composition 
> $M_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}$ (by the same relation $(\sim_\mathit{obi} \,;\, \mathit{sync})$ in Theorem~\ref{thm:mr-pals}).
> Consequently, we have:
> 
> 
> \begin{theorem}\label{thm:hybrid-pals} 
> The relation $(\sim_\mathit{obi} \,;\, \mathit{sync})$ 
> is a bisimulation between 
> the transition system by $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$ 
> and the big-step stable transition system induced by $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$.
> \end{theorem}
> 
> 
> 
> 
> 
Only in /Users/kquine/Downloads/texfiles/: intro-1.tex
diff ./intro.tex /Users/kquine/Downloads/texfiles/intro.tex
1,317c1,317
< % !TEX root = /Users/kquine/Dropbox/Research/Papers/2015/CPS-SMT-RTSS/cps-rtss.tex
< 
< 
< \section{Introduction}
< 
< %% Paragraph 1
< \emph{Virtually synchronous} distributed real-time systems consist of
< a number of \emph{distributed} controllers that should logically
< behave in a synchronous way. [[The devices may operate at different
< frequencies, but  communication happens at their hyper-period
< boundary.]] Designing and analyzing  such systems is very hard because
< of race conditions, clock skews, network delays, execution times, and
< the state space explosion caused by the interleavings. To overcome
< these problems, 
< the \emph{PALS} (physically asynchronous, logically synchronous) methodology
< \cite{pals-rtss09,mr-pals-journal,pals-tcs,al2012pattern} has been
< developed to reduce the design and verification of a virtually
< synchronous distributed real-time system to the much simpler task  of designing and
< verifying the underlying \emph{synchronous} models,
< provided that the  infrastructure can guarantee bounds
< on computation times, network delays, and imprecision of the local clocks.
< 
< 
< 
< 
< % %OLD paragraph 1:
< % %Virtually synchronous CPS, such as airplanes and cars, 
< % %are implemented as a network of distributed devices designed in a synchronous way.
< % \emph{Virtually synchronous} cyber physical systems (CPS)
< % consist of a number of distributed controllers that should logically act together in a synchronous way. 
< % The devices may operate at different frequencies, but the communication happens at their hyper-period boundary
< % (e.g., avionics, aerospace,  automotive, robotics, etc). 
< % The design and analysis of such systems is very hard because of race conditions, clock skews, network delays, and execution times. % in addition to the usual difficulties for non-distributed CPS.
< % For this reason, 
< % the PALS (physically asynchronous logically synchronous) methodology
< % \cite{pals-rtss09,mr-pals-journal,pals-tcs,al2012pattern} has been
< % developed to reduce the system complexity of a virtually  synchronous CPS,
< % provided that the network infrastructure gives \emph{performance bounds}
< % on computation times, network delays, and imprecisions of the local clocks.
< 
< 
< %% New paragraph 2:
< In this paper
< we present \emph{Hybrid PALS} that extends  PALS 
< to the important class of virtually synchronous \emph{cyber-physical
<   systems} (CPSs)---where controllers also interact with their local \emph{physical environments},
< whose \emph{continuous dynamics} can be  specified by  ordinary
< differential equations (ODEs)---which includes avionics, automotive, robotics, and medical systems. 
< We prove a bisimulation equivalence relating
< distributed hybrid systems and their underlying synchronous models.
< %This means that the design and analysis of distributed hybrid systems
< %can be reduced to  those of the synchronous models.
< %
< The initial steps towards a hybrid extension of PALS were taken
< in~\cite{hybrid-pals}. However, 
< that work imposes strong  conditions on sampling and response times
< of sensors and actuators, and, furthermore,  does not give 
< a bisimulation equivalence. % (but only a trace equivalence). % between a synchronous model and a distributed hybrid model. 
< 
< 
< 
< % %% OLD paragraph 2:
< % In this paper
< % we present \emph{Hybrid PALS} that extends the PALS methodology 
< % to virtually synchronous CPS given by \emph{distributed hybrid systems}.
< % The devices also interact with their local \emph{physical environments},
< % with continuous dynamics specified by using ordinary differential equations (ODE).
< % We show that there exists a \emph{bisimulation equivalence} relating
< % distributed hybrid systems and their underlying synchronous models.
< % This means that the design and analysis of distributed hybrid systems
< % can be reduced to  those of the synchronous models.
< % %
< % Hybrid PALS was first proposed in \cite{hybrid-pals}, but 
< % the work imposes strong stringent conditions on sampling and response timings
< % of sensors and actuators. Moreover, \cite{hybrid-pals} does not show
< % a bisimulation equivalence (but only a trace equivalence). % between a synchronous model and a distributed hybrid model. 
< 
< 
< %% NEW paragraph 3:
< Verifying the synchronous Hybrid PALS models is still challenging:
< inputs and parameter values can be any real number in certain
< intervals; different components  read their physical values and give
< actuator commands at  different times 
< because of  local clock skews, and these timings cannot be abstracted
< away; and the continuous dynamics  often involves 
< \emph{nonlinear} ODEs
< which in general may not have exact solutions.
< %Numerical simulations of ODEs cannot verify the correctness of the system.
< % Although the 
< % PALS methodology 
< % can greatly reduce the analysis effort 
< % caused by distributed real-time systems,
< % the difficulties raised by distributed hybrid systems
< % cannot be removed without using low-quality approximation on ODEs and local clocks.
< %which prevents to precisely analyze such hybrid systems.
< 
< 
< 
< % %%OLD paragraph 3:
< % However, 
< % formal analysis of virtually synchronous CPS with continuous dynamics is still very difficult.
< % Inputs or parameters of CPS can be any real numbers in a certain bound.
< % Different components will read their physical values at possibly different times 
< % according to their local clocks. 
< % The continuous dynamics of CPS often involves 
< % \emph{nonlinear} ODEs
< % which may not provide exact solutions in general.
< % %Numerical simulations of ODEs cannot verify the correctness of the system.
< % Although the 
< % PALS methodology 
< % can greatly reduce the analysis effort 
< % caused by distributed real-time systems,
< % the difficulties raised by distributed hybrid systems
< % cannot be removed without using low-quality approximation on ODEs and local clocks.
< % %which prevents to precisely analyze such hybrid systems.
< 
< %%% Polished paragraph 4:
< This paper presents SMT solving techniques to address the challenges
< of analyzing Hybrid PALS models of CPSs. The verification of
< a distributed CPS involving ODEs and clock skews is reduced to
< checking the satisfiability of SMT formulas over real numbers and
< ODEs, which 
< %This  satisfiability problem
<  is decidable up to any user-given precision $\delta > 0$ \cite{delta-comp,sat-ode}.
< %The number $\delta$, provided by the user, 
< %is the bound on numerical errors that is tolerable in the analysis.
< %%% (Peter): I removed the following sentence.
< % [[In this way, 
< % we can apply state-of-the-art SMT solving techniques that are %proven to be 
< % effective for analyzing \emph{discrete} controllers,
< % %combined with $\delta$-complete decision procedures
< % while  analyzing
< % the continuous dynamics of a CPS up to precision $\delta$.]] 
< 
< 
< %%% OLD Paragraph 4
< % We present symbolic techniques using SMT solving to analyze 
< % distributed CPS along with PALS.
< % %An SMT (satisfiability modulo theories) problem is to check the satisfiability of first-order formulas with respect to certain decidable logical theories
< % Formal analysis problems of distributed CPS, 
< % involving nonlinear ODEs and clock skews, 
< % are reduced to the satisfaction of SMT formulas over the real numbers and ODEs.
< % %
< % The satisfiability problem
< % (generally undecidable)
< %  is decidable up to any given precision $\delta > 0$ \cite{delta-comp,sat-ode}.
< % The number $\delta$, provided by the user, 
< % is the bound on numerical errors that is tolerable in the analysis.
< % By this approach, 
< % we can apply state-of-the-art SMT techniques that are %proven to be 
< % effective for analyzing \emph{discrete} controllers,
< % %combined with $\delta$-complete decision procedures
< % while precisely analyzing
< % the continuous dynamics of CPS
< % in a robust way under I/O sampling or timing jitters %numerical perturbations 
< % by $\delta$.
< 
< %%% Polished Paragraph 5:
< One problem with  SMT-based methods is 
< that they do not scale well for distributed hybrid systems with nonlinear ODEs.
< %The number of physical variables considered is usually less than dozens, 
< %and the temporal bound is typically less than hundreds. 
< We cope with this scalability problem as follows.
< First, the discrete part and the continuous part of the system are
< encoded separately, 
< so that ODEs are considered \emph{only after} the discrete part of the
< system has been  fully analyzed.
< Second, in addition to bounded reachability analysis, \emph{inductive}
< SMT analysis is used to verify safety properties,  without any time
< bound. 
< Third, compositional SMT analysis is used to analyze each part of a
< distributed CPS by a divide-and-conquer approach. % an arbitrary
<                                 % number of components.  
< %These methods are readily available for distributed CPS by simplifying the analysis problem using the PALS methodology. 
< %Without PALS, finding appropriate inductive or compositional conditions would be very difficult for distributed CPS.
< 
< %%% OLD paragraph 5:
< % One obstacle to SMT-based methods is 
< % that it is not scalable for distributed hybrid systems with nonlinear ODEs.
< % %The number of physical variables considered is usually less than dozens, 
< % %and the temporal bound is typically less than hundreds. 
< % We cope with this scalability problem as follows.
< % First, the discrete part and the continuous part of the system are separately encoded in SMT, 
< % so that ODEs are considered \emph{only after} the discrete part of the system is fully analyzed.
< % Second, inductive SMT analysis, besides bounded reachability, is used to verify safety properties of distributed CPS for unbounded time.
< % Third, compositional SMT analysis is used to analysis each part of distributed CPS by a divided-and-conquer approach. % an arbitrary number of components. 
< % %These methods are readily available for distributed CPS by simplifying the analysis problem using the PALS methodology. 
< % %Without PALS, finding appropriate inductive or compositional conditions would be very difficult for distributed CPS.
< 
< 
< %%% Polished Paragraph 6:
< %%Another  obstacle %to this approach 
< %%is that  SMT-based analysis 
< %%is currently inefficient
< %%for \emph{distributed} hybrid systems with nonlinear ODEs. 
< In distributed CPS, the 
< physical states of different components can be  correlated to each other.
< Consider, for example,  two adjacent rooms: the temperature of one room then immediately affects the
< temperature of the other room. %unless they are perfectly insulated. 
< Such  behaviors  are  specified as \emph{coupled} ODEs
< where variables evolve simultaneously over  time.
< %and ODE solving needs to take into account all coupled variables at the same time.
< %Therefore, 
< Existing SMT approaches use  non-modular encodings
< for such distributed hybrid systems. 
< %
< The size of the SMT formula can therefore be huge, which 
<  leads to the \emph{formula explosion problem}
< that makes  SMT-based analysis practically infeasible.
< 
< %%% OLD paragraph 6:
< % Another  obstacle %to this approach 
< % is that  SMT-based analysis 
< % is currently inefficient
< % for \emph{distributed} hybrid systems with nonlinear ODEs. 
< % In distributed CPS, 
< % physical states of different components can be physically correlated to each other.
< % For example, if we consider two adjacent rooms with thermostat controllers, the temperature of one room immediately affects the temperature of the other room. %unless they are perfectly insulated.
< % The behavior is specified as \emph{coupled} ODEs
< % where variables evolve simultaneously over continuous time.
< % %and ODE solving needs to take into account all coupled variables at the same time.
< % %Therefore, 
< % Existing SMT approaches use the non-modular encoding
< % for such distributed hybrid systems. 
< % %
< % The size of the SMT formula can be huge,
< % and  this leads to the \emph{formula explosion problem}
< % that makes such SMT-based analysis practically infeasible.
< 
< 
< %%% Polished stuff:
< To overcome this problem, we present a new SMT framework
< to  effectively encode formal analysis problems
< of distributed hybrid systems with coupled ODEs \emph{in a modular
<   way}.
< %%%% You commented out the following sentence. Was there
< %%%% something wrong???  Why not include it??
< %For a composition $H_1 \parallel \cdots \parallel H_n$ of $n$ hybrid systems,
< %where each component $H_i$ has $m_i$ control modes,
< %the size of the SMT formula by the new modular encoding is proportional to $\sum_{i=1}^n k_i$,
< %whereas by the previous non-modular encoding the size is proportional to $\prod_i k_i$.]
< The key idea is to use equation ``names'' %uninterpreted real function symbols %and universal quantification
< to logically decompose coupled variables in systems of ODEs in the SMT formula.
< %We provide an efficient SMT decision procedure for such formulas by the new encoding
< %for distributed hybrid systems.
< We show that 
< a satisfaction problem in  the new  theory 
< can be reduced to one in the standard theory of the real numbers \emph{at no cost}.
< %
< We have implemented our SMT techniques within the \textsf{dReal} SMT
< solver \cite{dReal}.
< We have applied our techniques on a range of advanced CPSs, including:
< a system for  turning an airplane, 
< %controlling the altitude of a quad-rotor UAV,
< %controlling the water level in a power plant,  
<  networked water tank
<  controllers,  and networked thermostat controllers.
< The experimental results show that these techniques can dramatically improve
< the performance of SMT-based verification of distributed CPSs.
< %that involve multiple control modes and nonlinear ODEs.
< % To the best of our knowledge, modular SMT encoding for 
< %(coupled) nonlinear ODEs and its efficient decision procedure have never been developed for distributed hybrid systems.
< 
< %%% OLD paragraph:
< % For this reason, 
< % we present a novel SMT framework
< % to  effectively encode formal analysis problems
< % of distributed hybrid systems with coupled ODEs \emph{in a modular way}.
< % %For a composition $H_1 \parallel \cdots \parallel H_n$ of $n$ hybrid systems,
< % %when each component $H_i$ has $m_i$ control modes,
< % %the size of the SMT formula by the new modular encoding is proportional to $\sum_{i=1}^n k_i$,
< % %whereas by the previous non-modular encoding the size is proportional to $\prod_i k_i$.
< % The key idea is to use equation ``names'' %uninterpreted real function symbols %and universal quantification
< % to logically decompose coupled variables in systems of ODEs in the SMT formula.
< % %We provide an efficient SMT decision procedure for such formulas by the new encoding
< % %for distributed hybrid systems.
< % %We show that 
< % The satisfaction problems of the new logical theory 
< % can be reduced to ones in the standard theory of the real numbers \emph{at no cost}.
< % %
< % We have implemented our SMT technique within the \textsf{dReal} SMT solver \cite{dReal}.
< % The experimental results show that our techniques can dramatically increase 
< % the performance of SMT-based analysis for nontrivial distributed CPS.
< % %that involve multiple control modes and nonlinear ODEs.
< % % To the best of our knowledge, modular SMT encoding for 
< % %(coupled) nonlinear ODEs and its efficient decision procedure have never been developed for distributed hybrid systems.
< 
< %\textbf{(Peter) I added the applications above from the commented-out list below..}
< 
< The rest of the paper is organized as follows.
< %
< Section~\ref{sec:pals} gives a background on  PALS.
< Section~\ref{sec:hybrid-pals} introduces Hybrid PALS.
< %involving nonlinear ODEs and clock skews. 
< Section~\ref{sec:smt-encoding} shows how synchronous Hybrid PALS models 
< and their verification problems (such as bounded reachability and inductive and compositional analysis)
< can be symbolically encoded as logical formulas.
< Section~\ref{sec:smt-logic} presents a new SMT framework supporting
< the 
< modular encoding of  distributed hybrid systems. % with coupled ODEs.  
< Section~\ref{sec:case-studies} gives an overview of the Hybrid PALS verification case studies.
< Finally,
< Section~\ref{sec:related-work} discusses related work,
< and 
< Section~\ref{sec:concl} gives some concluding remarks.
< 
< % experiments on nontrivial distributed CPS.
< %\begin{inparaenum}[(i)]
< %	\item a controller for turning an airplane,
< %	\item a controller for the attitude of a quad-rotor UAV,
< %	\item a steam boiler controller,
< %	\item networked water tank controllers,
< %	\item networked thermostat controllers, and
< %	\item an automated highway system.
< %\end{inparaenum}
< 
< 
---
> % !TEX root = /Users/kquine/Dropbox/Research/Papers/2015/CPS-SMT-RTSS/cps-rtss.tex
> 
> 
> \section{Introduction}
> 
> %% Paragraph 1
> \emph{Virtually synchronous} distributed real-time systems consist of
> a number of \emph{distributed} controllers that should logically
> behave in a synchronous way. [[The devices may operate at different
> frequencies, but  communication happens at their hyper-period
> boundary.]] Designing and analyzing  such systems is very hard because
> of race conditions, clock skews, network delays, execution times, and
> the state space explosion caused by the interleavings. To overcome
> these problems, 
> the \emph{PALS} (physically asynchronous, logically synchronous) methodology
> \cite{pals-rtss09,mr-pals-journal,pals-tcs,al2012pattern} has been
> developed to reduce the design and verification of a virtually
> synchronous distributed real-time system to the much simpler task  of designing and
> verifying the underlying \emph{synchronous} models,
> provided that the  infrastructure can guarantee bounds
> on computation times, network delays, and imprecision of the local clocks.
> 
> 
> 
> 
> % %OLD paragraph 1:
> % %Virtually synchronous CPS, such as airplanes and cars, 
> % %are implemented as a network of distributed devices designed in a synchronous way.
> % \emph{Virtually synchronous} cyber physical systems (CPS)
> % consist of a number of distributed controllers that should logically act together in a synchronous way. 
> % The devices may operate at different frequencies, but the communication happens at their hyper-period boundary
> % (e.g., avionics, aerospace,  automotive, robotics, etc). 
> % The design and analysis of such systems is very hard because of race conditions, clock skews, network delays, and execution times. % in addition to the usual difficulties for non-distributed CPS.
> % For this reason, 
> % the PALS (physically asynchronous logically synchronous) methodology
> % \cite{pals-rtss09,mr-pals-journal,pals-tcs,al2012pattern} has been
> % developed to reduce the system complexity of a virtually  synchronous CPS,
> % provided that the network infrastructure gives \emph{performance bounds}
> % on computation times, network delays, and imprecisions of the local clocks.
> 
> 
> %% New paragraph 2:
> In this paper
> we present \emph{Hybrid PALS} that extends  PALS 
> to the important class of virtually synchronous \emph{cyber-physical
>   systems} (CPSs)---where controllers also interact with their local \emph{physical environments},
> whose \emph{continuous dynamics} can be  specified by  ordinary
> differential equations (ODEs)---which includes avionics, automotive, robotics, and medical systems. 
> We prove a bisimulation equivalence relating
> distributed hybrid systems and their underlying synchronous models.
> %This means that the design and analysis of distributed hybrid systems
> %can be reduced to  those of the synchronous models.
> %
> The initial steps towards a hybrid extension of PALS were taken
> in~\cite{hybrid-pals}. However, 
> that work imposes strong  conditions on sampling and response times
> of sensors and actuators, and, furthermore,  does not give 
> a bisimulation equivalence. % (but only a trace equivalence). % between a synchronous model and a distributed hybrid model. 
> 
> 
> 
> % %% OLD paragraph 2:
> % In this paper
> % we present \emph{Hybrid PALS} that extends the PALS methodology 
> % to virtually synchronous CPS given by \emph{distributed hybrid systems}.
> % The devices also interact with their local \emph{physical environments},
> % with continuous dynamics specified by using ordinary differential equations (ODE).
> % We show that there exists a \emph{bisimulation equivalence} relating
> % distributed hybrid systems and their underlying synchronous models.
> % This means that the design and analysis of distributed hybrid systems
> % can be reduced to  those of the synchronous models.
> % %
> % Hybrid PALS was first proposed in \cite{hybrid-pals}, but 
> % the work imposes strong stringent conditions on sampling and response timings
> % of sensors and actuators. Moreover, \cite{hybrid-pals} does not show
> % a bisimulation equivalence (but only a trace equivalence). % between a synchronous model and a distributed hybrid model. 
> 
> 
> %% NEW paragraph 3:
> Verifying the synchronous Hybrid PALS models is still challenging:
> inputs and parameter values can be any real number in certain
> intervals; different components  read their physical values and give
> actuator commands at  different times 
> because of  local clock skews, and these timings cannot be abstracted
> away; and the continuous dynamics  often involves 
> \emph{nonlinear} ODEs
> which in general may not have exact solutions.
> %Numerical simulations of ODEs cannot verify the correctness of the system.
> % Although the 
> % PALS methodology 
> % can greatly reduce the analysis effort 
> % caused by distributed real-time systems,
> % the difficulties raised by distributed hybrid systems
> % cannot be removed without using low-quality approximation on ODEs and local clocks.
> %which prevents to precisely analyze such hybrid systems.
> 
> 
> 
> % %%OLD paragraph 3:
> % However, 
> % formal analysis of virtually synchronous CPS with continuous dynamics is still very difficult.
> % Inputs or parameters of CPS can be any real numbers in a certain bound.
> % Different components will read their physical values at possibly different times 
> % according to their local clocks. 
> % The continuous dynamics of CPS often involves 
> % \emph{nonlinear} ODEs
> % which may not provide exact solutions in general.
> % %Numerical simulations of ODEs cannot verify the correctness of the system.
> % Although the 
> % PALS methodology 
> % can greatly reduce the analysis effort 
> % caused by distributed real-time systems,
> % the difficulties raised by distributed hybrid systems
> % cannot be removed without using low-quality approximation on ODEs and local clocks.
> % %which prevents to precisely analyze such hybrid systems.
> 
> %%% Polished paragraph 4:
> This paper presents SMT solving techniques to address the challenges
> of analyzing Hybrid PALS models of CPSs. The verification of
> a distributed CPS involving ODEs and clock skews is reduced to
> checking the satisfiability of SMT formulas over real numbers and
> ODEs, which 
> %This  satisfiability problem
>  is decidable up to any user-given precision $\delta > 0$ \cite{delta-comp,sat-ode}.
> %The number $\delta$, provided by the user, 
> %is the bound on numerical errors that is tolerable in the analysis.
> %%% (Peter): I removed the following sentence.
> % [[In this way, 
> % we can apply state-of-the-art SMT solving techniques that are %proven to be 
> % effective for analyzing \emph{discrete} controllers,
> % %combined with $\delta$-complete decision procedures
> % while  analyzing
> % the continuous dynamics of a CPS up to precision $\delta$.]] 
> 
> 
> %%% OLD Paragraph 4
> % We present symbolic techniques using SMT solving to analyze 
> % distributed CPS along with PALS.
> % %An SMT (satisfiability modulo theories) problem is to check the satisfiability of first-order formulas with respect to certain decidable logical theories
> % Formal analysis problems of distributed CPS, 
> % involving nonlinear ODEs and clock skews, 
> % are reduced to the satisfaction of SMT formulas over the real numbers and ODEs.
> % %
> % The satisfiability problem
> % (generally undecidable)
> %  is decidable up to any given precision $\delta > 0$ \cite{delta-comp,sat-ode}.
> % The number $\delta$, provided by the user, 
> % is the bound on numerical errors that is tolerable in the analysis.
> % By this approach, 
> % we can apply state-of-the-art SMT techniques that are %proven to be 
> % effective for analyzing \emph{discrete} controllers,
> % %combined with $\delta$-complete decision procedures
> % while precisely analyzing
> % the continuous dynamics of CPS
> % in a robust way under I/O sampling or timing jitters %numerical perturbations 
> % by $\delta$.
> 
> %%% Polished Paragraph 5:
> One problem with  SMT-based methods is 
> that they do not scale well for distributed hybrid systems with nonlinear ODEs.
> %The number of physical variables considered is usually less than dozens, 
> %and the temporal bound is typically less than hundreds. 
> We cope with this scalability problem as follows.
> First, the discrete part and the continuous part of the system are
> encoded separately, 
> so that ODEs are considered \emph{only after} the discrete part of the
> system has been  fully analyzed.
> Second, in addition to bounded reachability analysis, \emph{inductive}
> SMT analysis is used to verify safety properties,  without any time
> bound. 
> Third, compositional SMT analysis is used to analyze each part of a
> distributed CPS by a divide-and-conquer approach. % an arbitrary
>                                 % number of components.  
> %These methods are readily available for distributed CPS by simplifying the analysis problem using the PALS methodology. 
> %Without PALS, finding appropriate inductive or compositional conditions would be very difficult for distributed CPS.
> 
> %%% OLD paragraph 5:
> % One obstacle to SMT-based methods is 
> % that it is not scalable for distributed hybrid systems with nonlinear ODEs.
> % %The number of physical variables considered is usually less than dozens, 
> % %and the temporal bound is typically less than hundreds. 
> % We cope with this scalability problem as follows.
> % First, the discrete part and the continuous part of the system are separately encoded in SMT, 
> % so that ODEs are considered \emph{only after} the discrete part of the system is fully analyzed.
> % Second, inductive SMT analysis, besides bounded reachability, is used to verify safety properties of distributed CPS for unbounded time.
> % Third, compositional SMT analysis is used to analysis each part of distributed CPS by a divided-and-conquer approach. % an arbitrary number of components. 
> % %These methods are readily available for distributed CPS by simplifying the analysis problem using the PALS methodology. 
> % %Without PALS, finding appropriate inductive or compositional conditions would be very difficult for distributed CPS.
> 
> 
> %%% Polished Paragraph 6:
> %%Another  obstacle %to this approach 
> %%is that  SMT-based analysis 
> %%is currently inefficient
> %%for \emph{distributed} hybrid systems with nonlinear ODEs. 
> In distributed CPS, the 
> physical states of different components can be  correlated to each other.
> Consider, for example,  two adjacent rooms: the temperature of one room then immediately affects the
> temperature of the other room. %unless they are perfectly insulated. 
> Such  behaviors  are  specified as \emph{coupled} ODEs
> where variables evolve simultaneously over  time.
> %and ODE solving needs to take into account all coupled variables at the same time.
> %Therefore, 
> Existing SMT approaches use  non-modular encodings
> for such distributed hybrid systems. 
> %
> The size of the SMT formula can therefore be huge, which 
>  leads to the \emph{formula explosion problem}
> that makes  SMT-based analysis practically infeasible.
> 
> %%% OLD paragraph 6:
> % Another  obstacle %to this approach 
> % is that  SMT-based analysis 
> % is currently inefficient
> % for \emph{distributed} hybrid systems with nonlinear ODEs. 
> % In distributed CPS, 
> % physical states of different components can be physically correlated to each other.
> % For example, if we consider two adjacent rooms with thermostat controllers, the temperature of one room immediately affects the temperature of the other room. %unless they are perfectly insulated.
> % The behavior is specified as \emph{coupled} ODEs
> % where variables evolve simultaneously over continuous time.
> % %and ODE solving needs to take into account all coupled variables at the same time.
> % %Therefore, 
> % Existing SMT approaches use the non-modular encoding
> % for such distributed hybrid systems. 
> % %
> % The size of the SMT formula can be huge,
> % and  this leads to the \emph{formula explosion problem}
> % that makes such SMT-based analysis practically infeasible.
> 
> 
> %%% Polished stuff:
> To overcome this problem, we present a new SMT framework
> to  effectively encode formal analysis problems
> of distributed hybrid systems with coupled ODEs \emph{in a modular
>   way}.
> %%%% You commented out the following sentence. Was there
> %%%% something wrong???  Why not include it??
> %For a composition $H_1 \parallel \cdots \parallel H_n$ of $n$ hybrid systems,
> %where each component $H_i$ has $m_i$ control modes,
> %the size of the SMT formula by the new modular encoding is proportional to $\sum_{i=1}^n k_i$,
> %whereas by the previous non-modular encoding the size is proportional to $\prod_i k_i$.]
> The key idea is to use equation ``names'' %uninterpreted real function symbols %and universal quantification
> to logically decompose coupled variables in systems of ODEs in the SMT formula.
> %We provide an efficient SMT decision procedure for such formulas by the new encoding
> %for distributed hybrid systems.
> We show that 
> a satisfaction problem in  the new  theory 
> can be reduced to one in the standard theory of the real numbers \emph{at no cost}.
> %
> We have implemented our SMT techniques within the \textsf{dReal} SMT
> solver \cite{dReal}.
> We have applied our techniques on a range of advanced CPSs, including:
> a system for  turning an airplane, 
> %controlling the altitude of a quad-rotor UAV,
> %controlling the water level in a power plant,  
>  networked water tank
>  controllers,  and networked thermostat controllers.
> The experimental results show that these techniques can dramatically improve
> the performance of SMT-based verification of distributed CPSs.
> %that involve multiple control modes and nonlinear ODEs.
> % To the best of our knowledge, modular SMT encoding for 
> %(coupled) nonlinear ODEs and its efficient decision procedure have never been developed for distributed hybrid systems.
> 
> %%% OLD paragraph:
> % For this reason, 
> % we present a novel SMT framework
> % to  effectively encode formal analysis problems
> % of distributed hybrid systems with coupled ODEs \emph{in a modular way}.
> % %For a composition $H_1 \parallel \cdots \parallel H_n$ of $n$ hybrid systems,
> % %when each component $H_i$ has $m_i$ control modes,
> % %the size of the SMT formula by the new modular encoding is proportional to $\sum_{i=1}^n k_i$,
> % %whereas by the previous non-modular encoding the size is proportional to $\prod_i k_i$.
> % The key idea is to use equation ``names'' %uninterpreted real function symbols %and universal quantification
> % to logically decompose coupled variables in systems of ODEs in the SMT formula.
> % %We provide an efficient SMT decision procedure for such formulas by the new encoding
> % %for distributed hybrid systems.
> % %We show that 
> % The satisfaction problems of the new logical theory 
> % can be reduced to ones in the standard theory of the real numbers \emph{at no cost}.
> % %
> % We have implemented our SMT technique within the \textsf{dReal} SMT solver \cite{dReal}.
> % The experimental results show that our techniques can dramatically increase 
> % the performance of SMT-based analysis for nontrivial distributed CPS.
> % %that involve multiple control modes and nonlinear ODEs.
> % % To the best of our knowledge, modular SMT encoding for 
> % %(coupled) nonlinear ODEs and its efficient decision procedure have never been developed for distributed hybrid systems.
> 
> %\textbf{(Peter) I added the applications above from the commented-out list below..}
> 
> The rest of the paper is organized as follows.
> %
> Section~\ref{sec:pals} gives a background on  PALS.
> Section~\ref{sec:hybrid-pals} introduces Hybrid PALS.
> %involving nonlinear ODEs and clock skews. 
> Section~\ref{sec:smt-encoding} shows how synchronous Hybrid PALS models 
> and their verification problems (such as bounded reachability and inductive and compositional analysis)
> can be symbolically encoded as logical formulas.
> Section~\ref{sec:smt-logic} presents a new SMT framework supporting
> the 
> modular encoding of  distributed hybrid systems. % with coupled ODEs.  
> Section~\ref{sec:case-studies} gives an overview of the Hybrid PALS verification case studies.
> Finally,
> Section~\ref{sec:related-work} discusses related work,
> and 
> Section~\ref{sec:concl} gives some concluding remarks.
> 
> % experiments on nontrivial distributed CPS.
> %\begin{inparaenum}[(i)]
> %	\item a controller for turning an airplane,
> %	\item a controller for the attitude of a quad-rotor UAV,
> %	\item a steam boiler controller,
> %	\item networked water tank controllers,
> %	\item networked thermostat controllers, and
> %	\item an automated highway system.
> %\end{inparaenum}
> 
> 
Only in .: kbae-bib.bib
Only in /Users/kquine/Downloads/texfiles/: kyungmin-intro.tex
Only in /Users/kquine/Downloads/texfiles/: kyungmin-pals.tex
Only in /Users/kquine/Downloads/texfiles/: kyungmin-related.tex
Only in .: main.bbl
Only in .: out
Only in /Users/kquine/Downloads/texfiles/: pals-1.tex
diff ./pals.tex /Users/kquine/Downloads/texfiles/pals.tex
1,295c1,295
< % !TEX root = /Users/kquine/Dropbox/Research/Papers/2015/CPS-SMT-RTSS/cps-rtss.tex
< 
< \section{Preliminaries on PALS}
< \label{sec:pals}
< 
< PALS transforms 
<  a \emph{synchronous design} $\mathit{SD}$ with  period $T$
< into a %\emph{correct-by-construction} 
< distributed real-time system $\mathcal{MA}(\mathit{SD}, T, \Gamma)$
< that satisfies the same temporal logic ($CTL^*$) formulas,
< provided that the underlying 
< infrastructure guarantees bounds %$\Gamma$ on network delays, execution times,  and clock skews, 
< $\Gamma = (\epsilon, \alpha_{\min}, \alpha_{\max}, \mu_{\min}, \mu_{\max})$
< with
< %
< \begin{inparaenum}[(i)]
< 	\item $\epsilon$ a maximal clock skew  with respect to the global clock,
< 	\item $[\alpha_{\min},\alpha_{\max}]$  bounds for processing
<           I/O and 
< 	executing a transition,   %%%  , and real-time scheduling
< 	and
< 	\item $[\mu_{\min}, \mu_{\max}]$ bounds  for the network transmission delay.
< 	%between any two nodes. % in the network.
< \end{inparaenum}
< This section overviews the synchronous models, % $\mathit{SD}$,
< the distributed  models, % $\mathcal{MA}(\mathit{SD}, T,\Gamma)$,
<  and their relationship %between $\mathit{SD}$ and $\mathcal{MA}(\mathit{SD}, T,\Gamma)$
< (we refer to~\cite{mr-pals-journal,pals-tcs} for details).
< 
< 
< \subsection{Discrete Synchronous Models}
< 
< The synchronous model $\mathit{SD}$ is specified  as 
< an \emph{ensemble}
< $\mathcal{E}$  of %(nondeterministic)
< state machines with input and output ports.
< In  each iteration, a machine performs a transition
< based on its current state and its inputs, %or its environment)
<  proceeds to the next state, and generates new outputs for the next iteration.
< 
< 
< \begin{definition}
< A  \emph{typed machine}  $M = (D_i,S,D_o,\delta_M)$
< is composed of:
< %
< \begin{inparaenum}[(i)]
< 	\item $D_i = D_{i_1} \times \cdots \times D_{i_n}$ an input set 
< 	(a value to the $k$-th \emph{input port}  is an element of  $D_{i_k}$), 
< 	% for $1 \leq k \leq n$, 
< 	\item $S$ a set of states, 
< 	\item $D_o =D_{o_1} \times \cdots \times D_{o_m}$ an output set,
< 	% (a value from the $j$-th \emph{output port} is an element of  $D_{o_j}$)
<         and 
< 	% for $1 \leq j \leq m$
< 	\item $\delta_M \subseteq (D_i \times S) \times (S \times D_o)$ a total
< 	transition relation.
< \end{inparaenum}  
< \end{definition}
< 
< 
< 
< 
< As illustrated in Fig.~\ref{fig:ensemble},
< a collection $\{M_j\}_{j\in J_S\cup J_F}$ of  state machines with different periods 
< can be composed into a 
< \emph{multirate ensemble} $\mathcal{E}$.
< The period of a slow machine $s \in J_S$ (with $\mathit{rate}(s) = 1$) is 
< a multiple of the period of a fast machine $f \in J_F$ (with $\mathit{rate}(f) > 1$). 
< A \emph{wiring diagram}, which has no connections between two fast
< machines,  connects the  input ports and output ports of the machines.
< 
< \begin{figure}
< \centering
< \includegraphics[clip=true,trim=0.3cm 0.4cm 0.3cm 0.4cm,width=\columnwidth]{ensemble.pdf}    
< \caption{A multirate ensemble $\mathcal{E}$,
< with $M_1$ and $M_2$ slow machines.
< %and $M_3$, $M_4$, and $M_5$ are fast machines.
< }  \label{fig:ensemble}
< \end{figure}
< 
< In each iteration, all components in $\mathcal{E}$ perform a
< transition each \emph{in lockstep}.
< A fast machine $f$ is \emph{slowed down} 
< and performs $k = \mathit{rate}(f)$ \emph{internal} transitions  in one global synchronous step.
< Since 
< a fast machine produces $k$-tuples of outputs in one step, 
< %but a slow machine only needs  a single input value.
< %Therefore,
< \emph{input adapters} are used 
< to generate single values (e.g., the last value, or 
< the average of the $k$ values) for a slow machine. 
< Likewise, a single output  from a slow machine is adapted to a $k$-tuple of inputs 
< for a fast machine.
< 
< 
< 
< 
< The \emph{synchronous composition}  of a multirate ensemble $\mathcal{E}$
< is equivalent to a single machine $M_\mathcal{E}$.
< If a machine in $\mathcal{E}$ has a feedback wire connected to itself or to another component, then the output becomes an input of the destination component in the next iteration.
< That is,  $M_\mathcal{E}$'s states %$S^{\mathcal{E}} = (\Pi_{j\in J} S_j) \times (\Pi_{j\in J}  D_\mathit{OF}^j)$,
< consist of the states %$S_j$ 
< of its subcomponents %$M_j$ 
< and
< the   ``feedback'' outputs. %$D_\mathit{OF}^j$ for $j \in J_S \cup J_F$
< %(i.e., the outputs from  $M_j$   to some machine in $\mathcal{E}$). 
< For example, 
< %the synchronous composition 
< $M_\mathcal{E}$ of 
< %the ensemble 
< $\mathcal{E}$ in Fig.~\ref{fig:ensemble} 
< is the machine given by the outer box. 
< %Notice that $M_\mathcal{E}$ can appear as a component 
< %in another multirate ensemble, resulting in hierarchical multirate systems.
< 
< %\textbf{(Peter) I have to add some discussion about the environments  and their timelessness ...}
< 
< The global \emph{environment} can be modeled as another typed
< machine, and \emph{local} environments are assumed to be composed with their
< controllers into a single typed machine. 
< This model is an untimed model (apart from the period $T$): 
< the result of applying a (controller or environment) transition is 
< independent of \emph{when}  the transition is applied in a round. 
< 
< \subsection{PALS Distributed  Real-Time Models}
< \label{pals-dist}
< 
< Each component in the  distributed model $\mathcal{MA}(\mathcal{E}, T, \Gamma)$
< is composed of a machine in $\mathcal{E}$ and \emph{wrappers} around it, as illustrated in Fig.~\ref{fig:wrappers}.
< %The outermost wrapper  is  the PALS wrapper, which encloses an input adaptor wrapper, 
< %which  encloses either a (slow) machine or a $k$-machine wrapper, 
< %which encloses a  (fast) machine. 
< In $\mathcal{MA}(\mathcal{E}, T, \Gamma)$,
< each machine performs at its own rate according to its local clock.
< %that deviates by less than $\epsilon$ from the global  clock.
< At the beginning of its periods, it reads its input from the layer above, 
< performs a transition, and then generates the outputs.
< %when the execution of the transition is finished.
< 
< \begin{figure}
< \centering
< \includegraphics[width=0.49\columnwidth,clip=true,trim=0.3cm 0.3cm 0.3cm 0.3cm]{Onion-f.pdf}
< \hfill
< \includegraphics[width=0.49\columnwidth,clip=true,trim=0.3cm 0.3cm 0.3cm 0.3cm]{Onion-s.pdf}
< \caption{The wrapper hierarchies %for fast machines (left) and slow machines (right) 
< in PALS distributed real-time  models.}
< \label{fig:wrappers}
< \end{figure}
< 
< 
< %
< A wrapper has I/O buffers,  timers, and access to the machine's  local clock.
< Each PALS wrapper %communicates with the other components, and 
< has the same \emph{global period $T$} and stores 
< received inputs  in its input buffer.
< When the $i$-th round begins %according to its local clock 
< (at time $u_0 \in (iT-\epsilon, iT+\epsilon)$),
< it delivers the contents of its input buffer to the inner input adaptor wrapper,
< and sets its \emph{backoff timer} to $2\epsilon -\mu_{min}$.
< %to prevent that outputs are sent out too early.
< When the execution of the inner components is finished \emph{and}
< the backoff timer expires, % (before $u_0 + \max(2\epsilon -\mu_{min}, \alpha_{max})$),
< the contents of the output buffer are sent out.% into the network, and
< \footnote{The outputs are sent out before $u_0 + \max(2\epsilon -\mu_{min}, \alpha_{max})$,
< and delivered to the destination before $u = \mu_{max} + u_0 +  \max(2\epsilon -\mu_{min}, \alpha_{max})$.
< Therefore, if $T\geq 2\epsilon + \mu_{max} + \max(2\epsilon -\mu_{min}, \alpha_{max})$,
< then all inputs are read in a round-consistent way since $u < (i+1)T - \epsilon$ \cite{pals-tcs}.}
< %%% Kyungmin: my understanding is that we give a brief overview of
< %%% Multirate PALS here; we do not try to _justify_ its correctness
< %%% here.
< %%% That has been done elsewhere.  Therefore, I suggest 
< %%% that we skip the details about why it works, especially
< %%% since many of the details do not seem to be used much later in the
< %%% paper. 
< 
< 
< 
< An input adaptor wrapper reads the inputs from the PALS wrapper
< and applies input adaptors %function
< %to get either a single value from a $k$-tuple input  for slow machines, or
< %a $k$-tuple of values from a single input for fast machines.
< for each global period $T$. % according to its local clock.
< A  $k$-machine wrapper
< \begin{inparaenum}[(i)]
< 	\item extracts each value from the $k$-tuple input and delivers it to the enclosed fast machine
< at each fast period $T/ k$, and
< 	\item delivers the $k$-\emph{tuples} from the outputs of the fast machine to its outer layer
< 	at each global period $T$.
< \end{inparaenum}
< 
< 
< 
< A fast machine $M_f$ %in $\mathcal{MA}(\mathcal{E}, T, \Gamma)$ 
< may \emph{not} be able to finish 
< all of its $k$ internal transitions in a global  round
<  \emph{before} the outputs must be sent to arrive before %the beginning of 
< the next round.
< The number of transitions that $M_f$ can perform before the deadline is 
<  $k'= 1+\lfloor \max(T - (2\epsilon + \mu_{max} + \alpha_{max_f}), 0)\cdot (k / T)\rfloor$,
<  where  $\alpha_{{\max}_f}$ is the maximal execution time for $M_f$.
< If $k' < k$,
< then $M_f$'s $k$-machine wrapper only sends the first $k'$ values
< (followed by $k - k'$ ``don't care'' values $\bot$).
< The input adaptor of each %slow machine's 
< input port whose source is $M_f$
< must %be \emph{$(k'+1)$-oblivious}, i.e., it 
< ignore the last $k - k'$ values
< $v_{k'+1}, \ldots, v_k$ in a $k$-tuple $(v_1, \ldots,  v_k)$.
< %
< 
< 
< \begin{figure}
< \begin{center}
< \begin{tikzpicture}[yscale=0.85,font=\footnotesize]
< \draw [->] (0,0) -- (8,0) node  [right] {fast};
< \draw [->] (0,1.2) -- (8,1.2) node [right] {slow};
< 
< \draw (2, -0.2) node [below] {$(i  T - \epsilon, i T + \epsilon)$} -- (2, 1.4);
< \draw[dashed] (1.7, -0.2) -- (1.7, 1.4)  ;
< \draw[dashed] (2.3, -0.2)  -- (2.3, 1.4);
< 
< \draw (7, -0.2) node [below] {$((i+1)  T - \epsilon, (i+1) T + \epsilon)$} -- (7, 1.4);
< \draw[dashed] (6.7, -0.2)  -- (6.7, 1.4);
< \draw[dashed] (7.3, -0.2)  -- (7.3, 1.4);
< 
< \draw [->,thick] (0.1, 0) -- (1.1, 1.2);
< \draw [->,thick] (0.2, 1.2) -- (1.4, 0);
< 
< \draw [->,thick] (2.8, 1.2) -- (3.8, 0);
< \draw [->,thick] (4.7, 0) -- (5.7, 1.2);
< \draw [->,thick,dotted] (6.2, 0) -- (7.2, 1.2);
< 
< \draw [very thick] (2.1, 1.25) -- (2.7, 1.25);
< \draw [very thick] (6.8, 1.25) -- (7.4, 1.25);
< 
< \draw [very thick] (2.1, 0.05) -- (2.4, 0.05); 
< \draw [very thick] (3.2, 0.05) -- (3.5, 0.05); \draw (3.25, -0.1) -- (3.25, 0.2);
< \draw [very thick] (4.3, 0.05) -- (4.6, 0.05); \draw (4.5, -0.1) -- (4.5, 0.2);
< \draw [very thick] (5.7, 0.05) -- (6.0, 0.05); \draw (5.75, -0.1) --(5.75, 0.2);
< 
< \end{tikzpicture}
< \caption{Timeline for $\mathcal{MA}(\mathcal{E}, T, \Gamma)$ ($k=4$ and $k' = 3$).
< Diagonal arrows denote network transmission and short horizontal lines denote the execution.
< The dotted arrow illustrates that the outputs can arrive after the beginning of the next round 
< %for the slow component 
< if the fast machine waits until all its transitions are finished.
< \label{fig:mr-timeline}}
< \end{center}
< \end{figure} 
< 
< 
< 
< \subsection{Relating the Synchronous and Distributed Models}
< 
< In  $\mathcal{MA}(\mathcal{E}, T, \Gamma)$,
< network transmission can happen only in the time interval  $(iT+\epsilon, (i+1)T-\epsilon)$
< for each $i$-th period, as depicted in Fig.~\ref{fig:mr-timeline}.
< Therefore, at each time $iT - \epsilon$, all the input buffers of the PALS wrappers are full, 
< and all the other input and output buffers are empty.
< A \emph{stable state} of the distributed model $\mathcal{MA}(\mathcal{E}, T, \Gamma)$
< is a snapshot of the system at each time $iT - \epsilon$,
< just before the components in $\mathcal{MA}(\mathcal{E}, T, \Gamma)$ 
< start performing local machine transitions \cite{pals-tcs}.
< 
< 
< 
< \emph{Big-step} transitions are defined between two stable states of $\mathcal{MA}(\mathcal{E}, T, \Gamma)$,
< and they are related to single steps of the synchronous composition
< $M_{\mathcal{E}}$ through the 
< %
<   function $\mathit{sync}$ 
< associating to each stable state  the corresponding state in  $M_{\mathcal{E}}$.
< %
< Two stable states are related by $s_1 \sim_\mathit{obi} s_2$ iff 
< their  machine states are identical
< and 
< their corresponding input buffer contents \emph{cannot} be
< distinguished by input adaptors.  
< 
< \begin{theorem}\label{thm:mr-pals}   \cite{mr-pals-journal}
< The relation $(\sim_\mathit{obi} \,;\, \mathit{sync})$ 
< is a bisimulation between 
< the transition system induced by $M_{\mathcal{E}}$
< and the big-step stable transition system induced by $\mathcal{MA}(\mathcal{E}, T, \Gamma)$.
< \end{theorem}
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
---
> % !TEX root = /Users/kquine/Dropbox/Research/Papers/2015/CPS-SMT-RTSS/cps-rtss.tex
> 
> \section{Preliminaries on PALS}
> \label{sec:pals}
> 
> PALS transforms 
>  a \emph{synchronous design} $\mathit{SD}$ with  period $T$
> into a %\emph{correct-by-construction} 
> distributed real-time system $\mathcal{MA}(\mathit{SD}, T, \Gamma)$
> that satisfies the same temporal logic ($CTL^*$) formulas,
> provided that the underlying 
> infrastructure guarantees bounds %$\Gamma$ on network delays, execution times,  and clock skews, 
> $\Gamma = (\epsilon, \alpha_{\min}, \alpha_{\max}, \mu_{\min}, \mu_{\max})$
> with
> %
> \begin{inparaenum}[(i)]
> 	\item $\epsilon$ a maximal clock skew  with respect to the global clock,
> 	\item $[\alpha_{\min},\alpha_{\max}]$  bounds for processing
>           I/O and 
> 	executing a transition,   %%%  , and real-time scheduling
> 	and
> 	\item $[\mu_{\min}, \mu_{\max}]$ bounds  for the network transmission delay.
> 	%between any two nodes. % in the network.
> \end{inparaenum}
> This section overviews the synchronous models, % $\mathit{SD}$,
> the distributed  models, % $\mathcal{MA}(\mathit{SD}, T,\Gamma)$,
>  and their relationship %between $\mathit{SD}$ and $\mathcal{MA}(\mathit{SD}, T,\Gamma)$
> (we refer to~\cite{mr-pals-journal,pals-tcs} for details).
> 
> 
> \subsection{Discrete Synchronous Models}
> 
> The synchronous model $\mathit{SD}$ is specified  as 
> an \emph{ensemble}
> $\mathcal{E}$  of %(nondeterministic)
> state machines with input and output ports.
> In  each iteration, a machine performs a transition
> based on its current state and its inputs, %or its environment)
>  proceeds to the next state, and generates new outputs for the next iteration.
> 
> 
> \begin{definition}
> A  \emph{typed machine}  $M = (D_i,S,D_o,\delta_M)$
> is composed of:
> %
> \begin{inparaenum}[(i)]
> 	\item $D_i = D_{i_1} \times \cdots \times D_{i_n}$ an input set 
> 	(a value to the $k$-th \emph{input port}  is an element of  $D_{i_k}$), 
> 	% for $1 \leq k \leq n$, 
> 	\item $S$ a set of states, 
> 	\item $D_o =D_{o_1} \times \cdots \times D_{o_m}$ an output set,
> 	% (a value from the $j$-th \emph{output port} is an element of  $D_{o_j}$)
>         and 
> 	% for $1 \leq j \leq m$
> 	\item $\delta_M \subseteq (D_i \times S) \times (S \times D_o)$ a total
> 	transition relation.
> \end{inparaenum}  
> \end{definition}
> 
> 
> 
> 
> As illustrated in Fig.~\ref{fig:ensemble},
> a collection $\{M_j\}_{j\in J_S\cup J_F}$ of  state machines with different periods 
> can be composed into a 
> \emph{multirate ensemble} $\mathcal{E}$.
> The period of a slow machine $s \in J_S$ (with $\mathit{rate}(s) = 1$) is 
> a multiple of the period of a fast machine $f \in J_F$ (with $\mathit{rate}(f) > 1$). 
> A \emph{wiring diagram}, which has no connections between two fast
> machines,  connects the  input ports and output ports of the machines.
> 
> \begin{figure}
> \centering
> \includegraphics[clip=true,trim=0.3cm 0.4cm 0.3cm 0.4cm,width=\columnwidth]{ensemble.pdf}    
> \caption{A multirate ensemble $\mathcal{E}$,
> with $M_1$ and $M_2$ slow machines.
> %and $M_3$, $M_4$, and $M_5$ are fast machines.
> }  \label{fig:ensemble}
> \end{figure}
> 
> In each iteration, all components in $\mathcal{E}$ perform a
> transition each \emph{in lockstep}.
> A fast machine $f$ is \emph{slowed down} 
> and performs $k = \mathit{rate}(f)$ \emph{internal} transitions  in one global synchronous step.
> Since 
> a fast machine produces $k$-tuples of outputs in one step, 
> %but a slow machine only needs  a single input value.
> %Therefore,
> \emph{input adapters} are used 
> to generate single values (e.g., the last value, or 
> the average of the $k$ values) for a slow machine. 
> Likewise, a single output  from a slow machine is adapted to a $k$-tuple of inputs 
> for a fast machine.
> 
> 
> 
> 
> The \emph{synchronous composition}  of a multirate ensemble $\mathcal{E}$
> is equivalent to a single machine $M_\mathcal{E}$.
> If a machine in $\mathcal{E}$ has a feedback wire connected to itself or to another component, then the output becomes an input of the destination component in the next iteration.
> That is,  $M_\mathcal{E}$'s states %$S^{\mathcal{E}} = (\Pi_{j\in J} S_j) \times (\Pi_{j\in J}  D_\mathit{OF}^j)$,
> consist of the states %$S_j$ 
> of its subcomponents %$M_j$ 
> and
> the   ``feedback'' outputs. %$D_\mathit{OF}^j$ for $j \in J_S \cup J_F$
> %(i.e., the outputs from  $M_j$   to some machine in $\mathcal{E}$). 
> For example, 
> %the synchronous composition 
> $M_\mathcal{E}$ of 
> %the ensemble 
> $\mathcal{E}$ in Fig.~\ref{fig:ensemble} 
> is the machine given by the outer box. 
> %Notice that $M_\mathcal{E}$ can appear as a component 
> %in another multirate ensemble, resulting in hierarchical multirate systems.
> 
> %\textbf{(Peter) I have to add some discussion about the environments  and their timelessness ...}
> 
> The global \emph{environment} can be modeled as another typed
> machine, and \emph{local} environments are assumed to be composed with their
> controllers into a single typed machine. 
> This model is an untimed model (apart from the period $T$): 
> the result of applying a (controller or environment) transition is 
> independent of \emph{when}  the transition is applied in a round. 
> 
> \subsection{PALS Distributed  Real-Time Models}
> \label{pals-dist}
> 
> Each component in the  distributed model $\mathcal{MA}(\mathcal{E}, T, \Gamma)$
> is composed of a machine in $\mathcal{E}$ and \emph{wrappers} around it, as illustrated in Fig.~\ref{fig:wrappers}.
> %The outermost wrapper  is  the PALS wrapper, which encloses an input adaptor wrapper, 
> %which  encloses either a (slow) machine or a $k$-machine wrapper, 
> %which encloses a  (fast) machine. 
> In $\mathcal{MA}(\mathcal{E}, T, \Gamma)$,
> each machine performs at its own rate according to its local clock.
> %that deviates by less than $\epsilon$ from the global  clock.
> At the beginning of its periods, it reads its input from the layer above, 
> performs a transition, and then generates the outputs.
> %when the execution of the transition is finished.
> 
> \begin{figure}
> \centering
> \includegraphics[width=0.49\columnwidth,clip=true,trim=0.3cm 0.3cm 0.3cm 0.3cm]{Onion-f.pdf}
> \hfill
> \includegraphics[width=0.49\columnwidth,clip=true,trim=0.3cm 0.3cm 0.3cm 0.3cm]{Onion-s.pdf}
> \caption{The wrapper hierarchies %for fast machines (left) and slow machines (right) 
> in PALS distributed real-time  models.}
> \label{fig:wrappers}
> \end{figure}
> 
> 
> %
> A wrapper has I/O buffers,  timers, and access to the machine's  local clock.
> Each PALS wrapper %communicates with the other components, and 
> has the same \emph{global period $T$} and stores 
> received inputs  in its input buffer.
> When the $i$-th round begins %according to its local clock 
> (at time $u_0 \in (iT-\epsilon, iT+\epsilon)$),
> it delivers the contents of its input buffer to the inner input adaptor wrapper,
> and sets its \emph{backoff timer} to $2\epsilon -\mu_{min}$.
> %to prevent that outputs are sent out too early.
> When the execution of the inner components is finished \emph{and}
> the backoff timer expires, % (before $u_0 + \max(2\epsilon -\mu_{min}, \alpha_{max})$),
> the contents of the output buffer are sent out.% into the network, and
> \footnote{The outputs are sent out before $u_0 + \max(2\epsilon -\mu_{min}, \alpha_{max})$,
> and delivered to the destination before $u = \mu_{max} + u_0 +  \max(2\epsilon -\mu_{min}, \alpha_{max})$.
> Therefore, if $T\geq 2\epsilon + \mu_{max} + \max(2\epsilon -\mu_{min}, \alpha_{max})$,
> then all inputs are read in a round-consistent way since $u < (i+1)T - \epsilon$ \cite{pals-tcs}.}
> %%% Kyungmin: my understanding is that we give a brief overview of
> %%% Multirate PALS here; we do not try to _justify_ its correctness
> %%% here.
> %%% That has been done elsewhere.  Therefore, I suggest 
> %%% that we skip the details about why it works, especially
> %%% since many of the details do not seem to be used much later in the
> %%% paper. 
> 
> 
> 
> An input adaptor wrapper reads the inputs from the PALS wrapper
> and applies input adaptors %function
> %to get either a single value from a $k$-tuple input  for slow machines, or
> %a $k$-tuple of values from a single input for fast machines.
> for each global period $T$. % according to its local clock.
> A  $k$-machine wrapper
> \begin{inparaenum}[(i)]
> 	\item extracts each value from the $k$-tuple input and delivers it to the enclosed fast machine
> at each fast period $T/ k$, and
> 	\item delivers the $k$-\emph{tuples} from the outputs of the fast machine to its outer layer
> 	at each global period $T$.
> \end{inparaenum}
> 
> 
> 
> A fast machine $M_f$ %in $\mathcal{MA}(\mathcal{E}, T, \Gamma)$ 
> may \emph{not} be able to finish 
> all of its $k$ internal transitions in a global  round
>  \emph{before} the outputs must be sent to arrive before %the beginning of 
> the next round.
> The number of transitions that $M_f$ can perform before the deadline is 
>  $k'= 1+\lfloor \max(T - (2\epsilon + \mu_{max} + \alpha_{max_f}), 0)\cdot (k / T)\rfloor$,
>  where  $\alpha_{{\max}_f}$ is the maximal execution time for $M_f$.
> If $k' < k$,
> then $M_f$'s $k$-machine wrapper only sends the first $k'$ values
> (followed by $k - k'$ ``don't care'' values $\bot$).
> The input adaptor of each %slow machine's 
> input port whose source is $M_f$
> must %be \emph{$(k'+1)$-oblivious}, i.e., it 
> ignore the last $k - k'$ values
> $v_{k'+1}, \ldots, v_k$ in a $k$-tuple $(v_1, \ldots,  v_k)$.
> %
> 
> 
> \begin{figure}
> \begin{center}
> \begin{tikzpicture}[yscale=0.85,font=\footnotesize]
> \draw [->] (0,0) -- (8,0) node  [right] {fast};
> \draw [->] (0,1.2) -- (8,1.2) node [right] {slow};
> 
> \draw (2, -0.2) node [below] {$(i  T - \epsilon, i T + \epsilon)$} -- (2, 1.4);
> \draw[dashed] (1.7, -0.2) -- (1.7, 1.4)  ;
> \draw[dashed] (2.3, -0.2)  -- (2.3, 1.4);
> 
> \draw (7, -0.2) node [below] {$((i+1)  T - \epsilon, (i+1) T + \epsilon)$} -- (7, 1.4);
> \draw[dashed] (6.7, -0.2)  -- (6.7, 1.4);
> \draw[dashed] (7.3, -0.2)  -- (7.3, 1.4);
> 
> \draw [->,thick] (0.1, 0) -- (1.1, 1.2);
> \draw [->,thick] (0.2, 1.2) -- (1.4, 0);
> 
> \draw [->,thick] (2.8, 1.2) -- (3.8, 0);
> \draw [->,thick] (4.7, 0) -- (5.7, 1.2);
> \draw [->,thick,dotted] (6.2, 0) -- (7.2, 1.2);
> 
> \draw [very thick] (2.1, 1.25) -- (2.7, 1.25);
> \draw [very thick] (6.8, 1.25) -- (7.4, 1.25);
> 
> \draw [very thick] (2.1, 0.05) -- (2.4, 0.05); 
> \draw [very thick] (3.2, 0.05) -- (3.5, 0.05); \draw (3.25, -0.1) -- (3.25, 0.2);
> \draw [very thick] (4.3, 0.05) -- (4.6, 0.05); \draw (4.5, -0.1) -- (4.5, 0.2);
> \draw [very thick] (5.7, 0.05) -- (6.0, 0.05); \draw (5.75, -0.1) --(5.75, 0.2);
> 
> \end{tikzpicture}
> \caption{Timeline for $\mathcal{MA}(\mathcal{E}, T, \Gamma)$ ($k=4$ and $k' = 3$).
> Diagonal arrows denote network transmission and short horizontal lines denote the execution.
> The dotted arrow illustrates that the outputs can arrive after the beginning of the next round 
> %for the slow component 
> if the fast machine waits until all its transitions are finished.
> \label{fig:mr-timeline}}
> \end{center}
> \end{figure} 
> 
> 
> 
> \subsection{Relating the Synchronous and Distributed Models}
> 
> In  $\mathcal{MA}(\mathcal{E}, T, \Gamma)$,
> network transmission can happen only in the time interval  $(iT+\epsilon, (i+1)T-\epsilon)$
> for each $i$-th period, as depicted in Fig.~\ref{fig:mr-timeline}.
> Therefore, at each time $iT - \epsilon$, all the input buffers of the PALS wrappers are full, 
> and all the other input and output buffers are empty.
> A \emph{stable state} of the distributed model $\mathcal{MA}(\mathcal{E}, T, \Gamma)$
> is a snapshot of the system at each time $iT - \epsilon$,
> just before the components in $\mathcal{MA}(\mathcal{E}, T, \Gamma)$ 
> start performing local machine transitions \cite{pals-tcs}.
> 
> 
> 
> \emph{Big-step} transitions are defined between two stable states of $\mathcal{MA}(\mathcal{E}, T, \Gamma)$,
> and they are related to single steps of the synchronous composition
> $M_{\mathcal{E}}$ through the 
> %
>   function $\mathit{sync}$ 
> associating to each stable state  the corresponding state in  $M_{\mathcal{E}}$.
> %
> Two stable states are related by $s_1 \sim_\mathit{obi} s_2$ iff 
> their  machine states are identical
> and 
> their corresponding input buffer contents \emph{cannot} be
> distinguished by input adaptors.  
> 
> \begin{theorem}\label{thm:mr-pals}   \cite{mr-pals-journal}
> The relation $(\sim_\mathit{obi} \,;\, \mathit{sync})$ 
> is a bisimulation between 
> the transition system induced by $M_{\mathcal{E}}$
> and the big-step stable transition system induced by $\mathcal{MA}(\mathcal{E}, T, \Gamma)$.
> \end{theorem}
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
Only in /Users/kquine/Downloads/texfiles/: peter-abstract.tex
Only in /Users/kquine/Downloads/texfiles/: peter-intro.tex
Only in /Users/kquine/Downloads/texfiles/: peter-pals.tex
Only in /Users/kquine/Downloads/texfiles/: peter-related.tex
Only in .: plot
Only in /Users/kquine/Downloads/texfiles/: related-1.tex
diff ./related.tex /Users/kquine/Downloads/texfiles/related.tex
1,75c1,75
< % !TEX root = /Users/kquine/Dropbox/Research/Papers/2015/CPS-SMT-RTSS/cps-rtss.tex
< 
< 
< \section{Related Work}
< \label{sec:related-work}
< 
< PALS~\cite{pals-rtss09,mr-pals-journal,pals-tcs,al2012pattern} targets
< distributed real-time systems, whose absence of continuous behaviors
< means that continuous behaviors and local clocks do not need to be
< taken into account in the synchronous models, which can therefore be
< verified by any explicit-state model checker. In contrast, Hybrid PALS
< synchronous models must take both clock skews and continuous behaviors
< into account and hence cannot be analyzed by explicit-state
< techniques. The first steps to add continuous behaviors to PALS were
< taken in~\cite{hybrid-pals}. Our work presents a more general
< model, where the relative sampling and actuating times are system
< parameters,  and also provides a crucial bisimulation result between
< the 
< synchronous and the distributed model. 
< 
< However,  the main difference is in the verification part. 
< Previous PALS work \cite{ftscs-journal} used explicit-state model checking, 
< based on numerical simulation for the continuous dynamics.
< Obviously, this cannot guarantee the correctness of hybrid systems.
< Furthermore,
< there was no hope of verifying a system for  all possible local clocks.
< The paper \cite{hybrid-pals} shows that two interconnected thermostats
< can be verified using \textsf{dReal}, but does not present any general SMT techniques for 
< Hybrid PALS.
< %Also, the previous work considers only particular sampling and actuating times.
<  %
< Our work presents SMT encodings for bounded reachability, inductive, and
< compositional analysis, % of hybrid PALS models,
< besides a new SMT framework and more case studies.
< 
< Because of the difficulty of handling SMT
< formulas over the reals with nonlinear functions, 
< SMT-solving-based verification is a fairly new direction for nonlinear hybrid
< systems. The research
< direction is initiated in~\cite{ratschan2007safety}, which uses constraint
< solving algorithms for handling nonlinear reachability problems. Two
< main lines of work that explicitly formulate problems as SMT formulas
< are based on the HySAT/iSAT
< solver~\cite{DBLP:journals/fmsd/FranzleH07,eggers2008sat}
< and the MathSAT
< solver~\cite{DBLP:conf/aaai/CimattiMT12,DBLP:conf/fmcad/CimattiMT12}.
< But neither efficient encodings of distributed hybrid systems nor 
< inductive and compositional analysis has  been
< investigated in existing work along these lines. 
< %
< It is also worth noting that 
< our methods are orthogonal to reachable set computation tools like SpaceEX~\cite{DBLP:conf/cav/FrehseGDCRLRGDM11}
< and Flow*~\cite{DBLP:conf/cav/ChenAS13},
< since they can also be used as ODE solvers for $\delta$-compete SMT (e.g., in \textsf{dReal}).
< 
< %On the other hand,
< %for reachable set computation, 
< %%the work on 
< %SpaceEX~\cite{DBLP:conf/cav/FrehseGDCRLRGDM11}
< %has involved methods for handling networks restricted to linear/multiaffine hybrid systems,
< %and 
< %Flow*~\cite{DBLP:conf/cav/ChenAS13} proposed an approach for verifying
< %nonlinear hybrid systems using Taylor model flowpipe construction. 
< %%
< %dReach~\cite{dReach}
< %encodes reachability problems of hybrid systems to SMT problems and
< %solves them using %a $\delta$-decision procedures, 
< %dReal~\cite{dReal}.
< %%
< %Our approach is different from dReach, 
< %since dReach \emph{explicitly} enumerates all mode paths of a hybrid automaton
< %to generate many small SMT formulas for these paths.
< 
< 
< 
---
> % !TEX root = /Users/kquine/Dropbox/Research/Papers/2015/CPS-SMT-RTSS/cps-rtss.tex
> 
> 
> \section{Related Work}
> \label{sec:related-work}
> 
> PALS~\cite{pals-rtss09,mr-pals-journal,pals-tcs,al2012pattern} targets
> distributed real-time systems, whose absence of continuous behaviors
> means that continuous behaviors and local clocks do not need to be
> taken into account in the synchronous models, which can therefore be
> verified by any explicit-state model checker. In contrast, Hybrid PALS
> synchronous models must take both clock skews and continuous behaviors
> into account and hence cannot be analyzed by explicit-state
> techniques. The first steps to add continuous behaviors to PALS were
> taken in~\cite{hybrid-pals}. Our work presents a more general
> model, where the relative sampling and actuating times are system
> parameters,  and also provides a crucial bisimulation result between
> the 
> synchronous and the distributed model. 
> 
> However,  the main difference is in the verification part. 
> Previous PALS work \cite{ftscs-journal} used explicit-state model checking, 
> based on numerical simulation for the continuous dynamics.
> Obviously, this cannot guarantee the correctness of hybrid systems.
> Furthermore,
> there was no hope of verifying a system for  all possible local clocks.
> The paper \cite{hybrid-pals} shows that two interconnected thermostats
> can be verified using \textsf{dReal}, but does not present any general SMT techniques for 
> Hybrid PALS.
> %Also, the previous work considers only particular sampling and actuating times.
>  %
> Our work presents SMT encodings for bounded reachability, inductive, and
> compositional analysis, % of hybrid PALS models,
> besides a new SMT framework and more case studies.
> 
> Because of the difficulty of handling SMT
> formulas over the reals with nonlinear functions, 
> SMT-solving-based verification is a fairly new direction for nonlinear hybrid
> systems. The research
> direction is initiated in~\cite{ratschan2007safety}, which uses constraint
> solving algorithms for handling nonlinear reachability problems. Two
> main lines of work that explicitly formulate problems as SMT formulas
> are based on the HySAT/iSAT
> solver~\cite{DBLP:journals/fmsd/FranzleH07,eggers2008sat}
> and the MathSAT
> solver~\cite{DBLP:conf/aaai/CimattiMT12,DBLP:conf/fmcad/CimattiMT12}.
> But neither efficient encodings of distributed hybrid systems nor 
> inductive and compositional analysis has  been
> investigated in existing work along these lines. 
> %
> It is also worth noting that 
> our methods are orthogonal to reachable set computation tools like SpaceEX~\cite{DBLP:conf/cav/FrehseGDCRLRGDM11}
> and Flow*~\cite{DBLP:conf/cav/ChenAS13},
> since they can also be used as ODE solvers for $\delta$-compete SMT (e.g., in \textsf{dReal}).
> 
> %On the other hand,
> %for reachable set computation, 
> %%the work on 
> %SpaceEX~\cite{DBLP:conf/cav/FrehseGDCRLRGDM11}
> %has involved methods for handling networks restricted to linear/multiaffine hybrid systems,
> %and 
> %Flow*~\cite{DBLP:conf/cav/ChenAS13} proposed an approach for verifying
> %nonlinear hybrid systems using Taylor model flowpipe construction. 
> %%
> %dReach~\cite{dReach}
> %encodes reachability problems of hybrid systems to SMT problems and
> %solves them using %a $\delta$-decision procedures, 
> %dReal~\cite{dReal}.
> %%
> %Our approach is different from dReach, 
> %since dReach \emph{explicitly} enumerates all mode paths of a hybrid automaton
> %to generate many small SMT formulas for these paths.
> 
> 
> 
Only in /Users/kquine/Downloads/texfiles/: smt-encoding-1.tex
diff ./smt-encoding.tex /Users/kquine/Downloads/texfiles/smt-encoding.tex
1,437c1,437
< % !TEX root = /Users/kquine/Dropbox/Research/Papers/2015/CPS-SMT-RTSS/cps-rtss.tex
< 
< 
< \section{Hybrid PALS Models as Logical Formulas}
< \label{sec:smt-encoding}
< 
< Theorem~\ref{thm:hybrid-pals} implies that 
<  verifying 
<  a distributed hybrid CPS $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$
< amounts to  verifying the much  simpler synchronous model $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$.
< %Directly analyzing such distributed systems is unfeasible in practice
< %due to the combinatorial explosion even for simple discrete systems \cite{pals-tcs}.
< However, it is still challenging to analyze $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$ 
< with (nonlinear)  continuous dynamics: 
< % (bounded by $\epsilon > 0$).
< The concrete values of the imprecise local clocks are unknown since they  %of local clocks 
< are determined on-the-fly by  \emph{clock synchronization} mechanisms, 
< %\cite{pals-rtss09,lynch-book}, 
< and 
< numerical simulation cannot  be used for nonlinear dynamics
< because numerical errors can be accumulated.
< 
< This section explains how verification  problems for  
< $\mathcal{E}\restriction_{\Pi}E_\mathcal{E}$, for \emph{all possible local clocks},
< can be  encoded as logical formulas over the real numbers and ODEs.
< The satisfiability of such formulas can then be automatically decided by SMT solving up to a given precision $\delta > 0$
< as shown in Section~\ref{sec:smt-logic}.
< %The idea is to express synchronous transitions in $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$ 
< %as formulas of the form $\phi(\vec{i}, \vec{y} \shortmid \vec{y'}, \vec{o})$, where 
< %\begin{inparaenum}[(i)]
< %	\item $\vec{i}$ denotes the inputs, 
< %	\item $\vec{y}$ denotes the states  at the beginning of the round at time $iT - \epsilon$,
< %	\item $\vec{y'}$ denotes the states at the end of the round at time $(i+1)T - \epsilon$, and 
< %	\item $\vec{o}$ denotes the outputs.
< %\end{inparaenum}
< %Using $\phi(\vec{i}, \vec{x} \shortmid \vec{x'}, \vec{o})$ as building blocks,
< %we show formulas for bounded analysis, inductive analysis, 
< %and compositional analysis of parameterized systems.
< 
< 
< \subsection{Encoding Environment-Restricted Controllers}
< \label{sec:discrete-encoding}
< 
< A controller $M$ can be 
< expressed as a logical formula %over discrete domain
< %of the form 
< $\phi_M(\vec{i}, \vec{y} \shortmid \vec{y'}, \vec{o})$,
< with variables
< $\vec{i}$, $\vec{y}$, $\vec{y'}$, and $\vec{o}$  denoting,
< respectively,  input, 
<  the current state, 
<  the next state, and output.
< 
< \begin{definition}
< For  $M = (D_i,S,D_o,\delta_M)$,
< the formula $\phi_M$ is defined as
< $\phi_{M}(\vec{d}_i, s \shortmid s',  \vec{d}_o)
< \iff
< ( (\vec{d}_i, s), (s', \vec{d}_o) ) \in \delta_{M}$.
< \end{definition}
< 
< 
< 
< A physical environment $E_M$ can be encoded  as 
< a formula $\phi_{E_M}(\vec{a},u_0,u_t,\vec{v} \shortmid \vec{x})$  over the real numbers %and ODEs
< %of the form $\phi_{E_M}(\vec{a},u_0,u_t,\vec{v} \shortmid \vec{x})$,
< with: \emph{unary function symbols} $\vec{x}$ denoting the
< trajectories of $E_M$'s physical parameters $\vec{x}$, and 
< 	\emph{variables} $\vec{a}$, $u_0$, $u_t$, and $\vec{v}$
<         denoting, respectively,  control commands, % from its controller $M$, 
< 		 the 
< 		times at the beginning and the end of the trajectory duration, and 
< 		the  initial values of the trajectories $\vec{x}$ at time $u_0$.
< 
< 
< If the continuous dynamics of $\vec{x}$ is specified as a system of ODEs
< $\frac{\mathrm{d}\vec{x}}{\mathrm{d}t}= F_{\vec{a}}(\vec{x},t)$
< for a control command $\vec{a}$
< during a time interval $[u_0,u_t]$, 
< then the formula $\phi_{E_M}$ 
< includes universal quantification over time along with solutions of the ODEs, such as a formula of the form:
< \[
< \bigvee \big(\mathit{guard}(\vec{a}) \rightarrow
< \forall t \in [u_0,u_t].\;
< \vec{x}(t) = \vec{v} + \int_0^{t-u_0} \!  F_{\vec{a}}(\vec{x},t)\,\mathrm{d}t
< \big)
< \]
< %For example, 
< %the formula $\phi_{E_M}(\mathit{rate}_M,u_0,u_t,v_M \shortmid \alpha_M)$
< %for 
< %%an environment 
< %$E_M$ of a subcontroller $M$ in the airplane example is given by:
< %$\forall t \in [u_0, u_t].\; \alpha_M(t) = v_M + \int_0^{t-u_0}  \mathit{rate}_M \,\mathrm{d}t$.
< %where the surface angle $\alpha_M$ follows the ODE
< %$\frac{\mathrm{d}\alpha_M}{\mathrm{d}t} = \mathit{rate}_M$
< %from the current angle $v_M$ in the time interval $[0,u]$.
< 
< 
< \begin{definition}
< For %a physical environment 
< $E_M = (C, \vec{x}, \Lambda)$,
< %the formula $\phi_{E_M}$ is defined as
< $\phi_{E_M}(\vec{a},u_0,u_t,\vec{v} \shortmid \vec{x})$
< iff
< $((\vec{a},u_t-u_0,\vec{v}), \vec{\tau}) \in \Lambda$
< and $\vec{x}(t) = \vec{\tau}(t - u_0)$ for $t \in [u_0, u_t]$.
< \end{definition}
< 
< The encoding $\phi_{M \restriction_\pi E_M}$ of the 
<  environment restriction $M \restriction_\pi E_M$
< has the form
< $\phi_{M \restriction_\pi E_M}^{T,i}(\vec{i}, \vec{y}, \vec{v} \shortmid \vec{y'}, \vec{v'}, \vec{o})$,
< with variables:
< \begin{inparaenum}[(i)]
< 	\item $\vec{i}$ denoting input, 
< 	\item $(\vec{y},\vec{v})$ denoting a state  at the beginning of the round 
< 		(at time $iT - \epsilon$),
< 	\item $(\vec{y'},\vec{v'})$ denoting a state at the end of the round 
< 		(at time $(i+1)T - \epsilon$), and 
< 	\item $\vec{o}$ denoting output.
< \end{inparaenum}
< %
< Instead of  writing $iT - \epsilon$ and $(i+1)T - \epsilon$  in $\phi_{M \restriction_\pi E_M}$,
< we use the ``$\epsilon$-shifted''  time axis for the interval $[iT, (i+1)T]$. %for the formula $\phi_{M \restriction_\pi E_M}$.
< %
< %A formula $\phi_{M \restriction_\pi E_M}$ 
< %is basically the direct translation of its formal definition in Definition~\ref{def:env-res}.
< Due to clock skews, 
< the exact values of sampling time $u_I = (c_M(i)+t_I)-(iT-\epsilon)$
< and response time $u_R = (c_M(i)+t_R)-(iT-\epsilon)$ are unknown. 
< Because $iT - \epsilon < c_M(i) < iT + \epsilon$,
< we represent those times as formulas 
< $t_I < u_I < t_I + 2\epsilon$ and $t_R < u_R < t_R + 2\epsilon$
< in $\phi_{M \restriction_\pi E_M}$.
< 
< 
< 
< 
< 
< 
< \begin{definition}
< For an environment restriction $M \restriction_\pi E_M$
< with  interface % projection functions
< $\pi$, %=(\pi_T, \pi_R, \pi_I, \pi_C, \pi_O)
< %the formula 
< $\phi_{M \restriction_\pi E_M}^{T,i}(\vec{i}, \vec{y}, \vec{v} \shortmid \vec{y'}, \vec{v'}, \vec{o})$
< is defined % from Definition~\ref{def:env-res}
< by:
< \begin{align*}
< \begin{alignedat}{3}
< \exists \vec{a},\vec{a'}, \vec{v}_I, \vec{v}_R, u_I, u_R, t_I, t_R.\;
< &&&
< \vec{a} = \pi_C(\vec{y})
< \\
< \wedge\;
< \phi_{E_M}(\vec{a},iT,iT+u_I,\vec{v} \shortmid \vec{x})
< &\;\;\wedge\;\;&&
< \vec{v}_I = \vec{x}(iT+u_I)
< \\
< \wedge\;
< \phi_{E_M}(\vec{a},iT+u_I,iT+u_R,\vec{v}_I \shortmid \vec{x})
< &\;\;\wedge\;\;&&
< \vec{v}_R = \vec{x}(iT+u_R)
< \\
< \wedge\;
< \phi_M(\vec{i},\langle\vec{y},\pi_O(\vec{v}_I)\rangle \shortmid \langle\vec{y'},\pi_O(\vec{v'})\rangle, \vec{o})
< &\;\;\wedge\;\;&&
< \vec{a'} = \pi_C(\vec{y'})
< \\
< \wedge\;
< \phi_{E_M}(\vec{a'},iT+u_R, (i+1)T ,\vec{v}_R \shortmid \vec{x})
< &\;\;\wedge\;\;&&
< \vec{v'} = \vec{x}((i+1)T)
< \\
< \wedge\;
< t_I = \pi_I(\vec{y})
< &\;\;\wedge\;\;&&
< t_R = \pi_R(\vec{y},\vec{i})
< \end{alignedat}
< \\
< \begin{alignedat}{3}
< \wedge\;
< (t_I < u_I < t_I + 2\epsilon)
< \;\wedge\;
< (t_R < u_R < t_R + 2\epsilon)
< \end{alignedat}
< \end{align*}
< %
< Notice that a local clock $c_M$ (and the round number $\pi_T$)
< are abstracted from the formula.
< That is,
< $\phi_{M \restriction_\pi E_M}(\vec{i}, s, \vec{v} \shortmid s', \vec{v'}, \vec{o})$
< iff
< $( (\vec{i}, (s,\vec{v})), ((s',\vec{v'}), \vec{o}) ) \in \delta_{M \restriction_\pi E_M}$
< for some $c_M$.
< \end{definition}
< 
< 
< 
< 
< \subsection{Encoding Hybrid Ensembles}
< 
< %Recall that 
< The synchronous composition  of an ensemble 
< $\mathcal{E}$ is equivalent to a single machine $M_\mathcal{E}$
< in which all machines perform their transitions in lockstep.
< Each fast machine $f$  performs $k = \mathit{rate}(f)$  internal transitions in one step.
< %
< The encoding
< $\phi_{(M \restriction_\pi E_M)^{\times k}}^{T, i}$
< of the $k$-step \emph{deceleration} of %an environment restriction 
< $M \restriction_\pi E_M$
< is defined by sequentially 
< composing the 
< $k$ formulas $\phi_{M \restriction_\pi E_M}^{T/k,ik},\ldots,\phi_{M \restriction_\pi E_M}^{T/k,(ik+k-1)}$
< corresponding  to the $k$  \emph{subintervals} $[(ik+n-1)T/k-\epsilon,(ik+n)T/k-\epsilon]$ 
< for $n=1,\ldots,k$.
< 
< \begin{definition}
< Given $M \restriction_\pi E_M$ and $k \in \mathbb{N}$,
< the formula
< $\phi_{(M \restriction_\pi E_M)^{\times k}}^{T,
<   i}(\langle\vec{i_1},\ldots,\vec{i_k}\rangle, \vec{y_0}, \vec{v_0}
< \shortmid \vec{y}_{k}, \vec{v}_{k},
< \langle\vec{o_1},\ldots,\vec{o_k}\rangle)$ is: 
< \[
< %(\exists \vec{y_1},\ldots, \vec{y}_{k-1}, \vec{v_1},\ldots, \vec{v}_{k-1})
< \exists\{\vec{y_n}, \vec{v_n}\}_{n=1}^{k-1}.\,
< \bigwedge_{n=1}^k \phi_{M \restriction_\pi E_M}^{T/k,(ik+n-1)}(\vec{i_n}, \vec{y}_{n-1}, \vec{v}_{n-1} \shortmid \vec{y_{n}}, \vec{v_{n}}, \vec{o}_n)
< \]
< \end{definition}
< 
< The wiring diagram of $\mathcal{E}$ is encoded as
< a conjunction of %appropriate 
< equalities between variables denoting input and output ports.
< Each equality corresponds to a connection in $\mathcal{E}$
< (together with an input adaptor for machines with different rates).
< %Since feedback outputs of one machine to itself or another machine 
< %becomes input of their destinations in the next step,
< %we use a separate set of variables for such output ports connected to other machines in $\mathcal{E}$.
< %$\phi_\mathit{wire}$ is a conjunction of equalities, together with
< %the input adaptors of $\{M_j\}_{j\in J_S\cup J_F}$,  given by the
< %wiring diagram of $\mathcal{E}$. 
< 
< 
< \begin{definition}
< %The formula 
< $\phi_\mathit{wire}$ is the conjunction of the equalities:
< \begin{inparaenum}[(i)]
< 	\item $\alpha_j^l(i_j^l) = i_e^n$
< 	for each connection from $\mathcal{E}$'s $n$-th input port to $M_j$'s $l$-th input port 
< 	with its input adaptor $\alpha_j^l$;
< 	\item $o_e^n = o_j^l$
< 	for each connection from $M_j$'s $l$-th output port to $\mathcal{E}$'s $n$-th output port; and
< 	\item $\alpha_j^l(i_j^l) = f_k^n$ and ${f_k^n}' = o_k^n$
< 	for each connection from $M_k$'s $n$-th output port to $M_j$'s $l$-th input port with its input adaptor $\alpha_j^l$,
< 	where $f_k^l$ denotes a feedback output from the previous step, 
< 	and ${f_k^l}'$ denotes one for the next step.
< \end{inparaenum}
< \end{definition}
< 
< 
< A hybrid ensemble $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$ 
< of machines  $\{M_j\}_{j\in J_S\cup J_F}$ with %physical 
< environments $\{E_{M_j}\}_{j\in J_S\cup J_F}$
< ($J_S$ denoting slow machines and $J_F$ denoting fast machines) is
< encoded as a formula 
< $\phi_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}^{T,i}(
< 	\vec{i}, \{\vec{z_j},\vec{f_j}\}_{j\in J_S\cup J_F}
< 	\shortmid 
< 	\{\vec{z'_j}, \vec{f_j'}\}_{j\in J_S\cup J_F}, \vec{o})$,
< %
< with variables $\vec{i}$, $\vec{z_j}$, $\vec{f_j}$, $\vec{z_j'}$,
< $\vec{f_j'}$, and $\vec{o}$ denoting, respectively, 
< inputs, the state of $M_j \restriction_{\pi_j} E_{M_j}$ at the beginning of the round 
< 		(at time $iT - \epsilon$),
< feedback outputs from the previous round,
< 	the  state of $M_j \restriction_{\pi_j} E_{M_j}$ at the end of the round 
< 		(at time $(i+1)T - \epsilon$), 
< the feedback outputs for the next round,	and 
< the output.
< 
< 
< \begin{definition}
< For a hybrid ensemble $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$, %of machines 
< %$\{M_j\}_{j\in J_S\cup J_F}$, their physical environments $\{E_{M_j}\}_{j\in J_S \cup J_F}$
< %and the time-invariant constraint $(\forall t.\; \psi)$,
< its encoding
< $\phi_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}^{T,i}(
< 	\vec{i}, \{\vec{y_j}, \vec{v_j},\vec{\mathit{f}_j}\}_{j\in J_S\cup J_F}
< 	\shortmid 
< 	\{\vec{y'_j}, \vec{v'_j}, \vec{\mathit{f}_j'}\}_{j\in J_S\cup J_F}, \vec{o})$ is:
< \begin{align*}
< %(\exists \{\vec{i_j},\vec{o_j}\}_{j\in J_S\cup J_F})\;
< \exists \{\vec{i_j},\vec{o_j}\}_{j\in J_S\cup J_F}.\,
< \textstyle\bigwedge_{s \in J_S}
< \big(\phi_{M_s \restriction_{\pi_s} E_{M_s}}^{T,i}(\vec{i_s}, \vec{y_s}, \vec{v_s} \shortmid \vec{y'_s}, \vec{v'_s}, \vec{o}_s)\big)
< \phantom{.}
< \\
< \wedge\;
< \textstyle\bigwedge_{f \in J_F}
< \big(\phi_{(M_f \restriction_{\pi_f} E_{M_f})^{\times\mathit{rate}(j)}}^{T,i}(\vec{i_f}, \vec{y_f}, \vec{v_f} \shortmid \vec{y'_f}, \vec{v'_f}, \vec{o}_f)\big)
< \phantom{.}
< \\
< \wedge\;
< \phi_\mathit{wire}(\vec{i},\vec{o},\{\vec{i_j},\vec{o_j},\vec{\mathit{f}_j},\vec{\mathit{f}_j'}\}_{j\in J_S\cup J_F})
< \;\wedge\;
< (\forall t.\; \psi).
< \end{align*}
< \end{definition}
< 
< By construction, a formula $\phi_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}^{T,i}$ is satisfiable
< iff there is a corresponding transition of the synchronous composition $M_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}$
< from $iT - \epsilon$ to $(i+1)T - \epsilon$ for \emph{some} local clocks.
< Therefore, by  the bisimulation equivalence (Theorem~\ref{thm:hybrid-pals}):
< 
< \begin{theorem}\label{thm:pals-encoding}
< $\phi_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}^{T,i}$ is satisfiable 
< iff for some local clocks, there exists a corresponding \emph{stable transition} in a distributed hybrid system  
< $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$   for $[iT - \epsilon,(i+1)T - \epsilon]$.
< \end{theorem}
< 
< \subsection{Encoding Verification Problems}
< 
< Our goal is to verify safety properties
< of a distributed CPS $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$.
< In general, a safety property of the system can be expressed as a formula of the form 
< $\forall t.  \mathit{safe}(\vec{z},t)$
< for  state variables $\vec{z}$ and time variable $t$.
< 
< 
< %For bounded analysis
< To verify %whether $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$
< a safety property %$\forall t.  \mathit{safe}(\vec{z},t)$
< up to a given bound $n \in \mathbb{N}$
< (i.e., for the time interval $[0,nT - \epsilon]$),
< we encode its \emph{bounded counterexamples}. %of $\forall t.  \mathit{safe}(\vec{z},t)$
< %up to the bound $n$.
< If the formula is unsatisfiable (i.e., no counterexample exists), 
< then, by Theorem~\ref{thm:pals-encoding},  the system satisfies the safety property in $[0,nT - \epsilon]$
< \emph{for any local clocks}.
< 
< 
< 
< \begin{definition}
< The verification problem for $\forall t.  \mathit{safe}(\vec{z},t)$
< %of $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$ 
< \emph{up to $n$ rounds} with  initial condition $\mathit{init}(\vec{z})$
< is encoded by:
< \begin{align*}
< \exists \vec{z}_0, \{\vec{z}_k, \vec{i}_k, \vec{o}_k, t_k\}_{k=1}^{n}.\;
< \textstyle\bigwedge_{k=1}^{n}
< \big(\phi_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}^{T,k}(
< 	\vec{i}_k, \vec{z}_{k-1}
< 	\shortmid 
< 	\vec{z}_{k}, \vec{o}_k)\big)
< \phantom{.}
< \\
< \wedge\;
< \mathit{init}(\vec{z}_0)
< \;\wedge\;
< \textstyle\bigvee_{k=1}^{n}
< \big(
< (k-1)T < t_{k} \leq T
< \wedge
< \neg\mathit{safe}(\vec{z}_k, t_{k}) 
< \big).
< \end{align*}
< \end{definition}
< 
< 
< For \emph{unbounded} verification of a safety property,
< we encode its inductive proof as a logical formula.
< The idea is to find an inductive condition $\mathit{ind}(\vec{z})$ 
< for synchronous transitions
< that corresponds to the beginning of a global round,
< and to show that $\mathit{ind}(\vec{z})$ implies %the safety property 
< $\mathit{safe}(\vec{z},t)$ 
< for that round.
< 
< \begin{definition} 
< The  verification problem for $\forall t. \mathit{safe}(\vec{z},t)$
< with an inductive condition $\mathit{ind}(\vec{z})$ is encoded  by:
< \begin{multline*}
< \forall \vec{z}, \vec{z'}, \vec{i}, \vec{o}.\;
< (\mathit{ind}(\vec{z})\;\wedge\;\phi_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}^{T,0}(\vec{i}, \vec{z}\shortmid \vec{z'}, \vec{o}))
< \\
< \implies
< \mathit{ind}(\vec{z'}) \;\wedge\; t \in [0,T].\,\mathit{safe}(\vec{z},t)
< .
< \end{multline*}
< \end{definition}
< 
< We also encode a divide-and-conquer proof
< to verify a safety property by compositional analysis. % as formulas.
< An input condition $\mathit{c}_\mathit{in}(\vec{i},\vec{z},t)$
< and an output condition $\mathit{c}_\mathit{out}(\vec{o},\vec{z},t)$ 
< during a global round
< are identified for synchronous transitions
< in such a way 
< that $\mathit{c}_\mathit{in}(\vec{i},\vec{z},t)$ implies %the safety property 
< $\mathit{safe}(\vec{z},t)$ for that round.
< %(time variable $t$ is included because of time-invariant constraints).
< %This method is very useful for parameterized systems (see Section~\ref{sec:case-studies}).
< 
< 
< \begin{definition} \label{def:compositional}
< The compositional analysis for $\forall t.  \mathit{safe}(\vec{z},t)$
< with I/O conditions $\mathit{c}_\mathit{in}(\vec{i},\vec{z},t)$ and $\mathit{c}_\mathit{out}(\vec{o},\vec{z},t)$
< is encoded by:
< \begin{multline*}
< \forall \vec{z}, \vec{z'}, \vec{i}, \vec{o}.\;
< (\mathit{c}_\mathit{in}(\vec{i},\vec{z},t)
< \;\wedge\;
< \phi_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}^{T,0}(
< 	\vec{i}, \vec{z}
< 	\shortmid 
< 	\vec{z'}, \vec{o})
< )
< \\
< \implies
< \mathit{c}_\mathit{out}(\vec{o},\vec{z'},t) \;\wedge\; t \in [0,T].\, \mathit{safe}(\vec{z},t).
< \end{multline*}
< \end{definition}
< 
< The validity of such formulas for inductive or compositional  analysis can also be automatically checked 
< using SMT solving
< by checking the unsatisfiability of their \emph{negations}.
< 
< 
< 
< 
< 
< 
< 
< 
< 
---
> % !TEX root = /Users/kquine/Dropbox/Research/Papers/2015/CPS-SMT-RTSS/cps-rtss.tex
> 
> 
> \section{Hybrid PALS Models as Logical Formulas}
> \label{sec:smt-encoding}
> 
> Theorem~\ref{thm:hybrid-pals} implies that 
>  verifying 
>  a distributed hybrid CPS $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$
> amounts to  verifying the much  simpler synchronous model $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$.
> %Directly analyzing such distributed systems is unfeasible in practice
> %due to the combinatorial explosion even for simple discrete systems \cite{pals-tcs}.
> However, it is still challenging to analyze $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$ 
> with (nonlinear)  continuous dynamics: 
> % (bounded by $\epsilon > 0$).
> The concrete values of the imprecise local clocks are unknown since they  %of local clocks 
> are determined on-the-fly by  \emph{clock synchronization} mechanisms, 
> %\cite{pals-rtss09,lynch-book}, 
> and 
> numerical simulation cannot  be used for nonlinear dynamics
> because numerical errors can be accumulated.
> 
> This section explains how verification  problems for  
> $\mathcal{E}\restriction_{\Pi}E_\mathcal{E}$, for \emph{all possible local clocks},
> can be  encoded as logical formulas over the real numbers and ODEs.
> The satisfiability of such formulas can then be automatically decided by SMT solving up to a given precision $\delta > 0$
> as shown in Section~\ref{sec:smt-logic}.
> %The idea is to express synchronous transitions in $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$ 
> %as formulas of the form $\phi(\vec{i}, \vec{y} \shortmid \vec{y'}, \vec{o})$, where 
> %\begin{inparaenum}[(i)]
> %	\item $\vec{i}$ denotes the inputs, 
> %	\item $\vec{y}$ denotes the states  at the beginning of the round at time $iT - \epsilon$,
> %	\item $\vec{y'}$ denotes the states at the end of the round at time $(i+1)T - \epsilon$, and 
> %	\item $\vec{o}$ denotes the outputs.
> %\end{inparaenum}
> %Using $\phi(\vec{i}, \vec{x} \shortmid \vec{x'}, \vec{o})$ as building blocks,
> %we show formulas for bounded analysis, inductive analysis, 
> %and compositional analysis of parameterized systems.
> 
> 
> \subsection{Encoding Environment-Restricted Controllers}
> \label{sec:discrete-encoding}
> 
> A controller $M$ can be 
> expressed as a logical formula %over discrete domain
> %of the form 
> $\phi_M(\vec{i}, \vec{y} \shortmid \vec{y'}, \vec{o})$,
> with variables
> $\vec{i}$, $\vec{y}$, $\vec{y'}$, and $\vec{o}$  denoting,
> respectively,  input, 
>  the current state, 
>  the next state, and output.
> 
> \begin{definition}
> For  $M = (D_i,S,D_o,\delta_M)$,
> the formula $\phi_M$ is defined as
> $\phi_{M}(\vec{d}_i, s \shortmid s',  \vec{d}_o)
> \iff
> ( (\vec{d}_i, s), (s', \vec{d}_o) ) \in \delta_{M}$.
> \end{definition}
> 
> 
> 
> A physical environment $E_M$ can be encoded  as 
> a formula $\phi_{E_M}(\vec{a},u_0,u_t,\vec{v} \shortmid \vec{x})$  over the real numbers %and ODEs
> %of the form $\phi_{E_M}(\vec{a},u_0,u_t,\vec{v} \shortmid \vec{x})$,
> with: \emph{unary function symbols} $\vec{x}$ denoting the
> trajectories of $E_M$'s physical parameters $\vec{x}$, and 
> 	\emph{variables} $\vec{a}$, $u_0$, $u_t$, and $\vec{v}$
>         denoting, respectively,  control commands, % from its controller $M$, 
> 		 the 
> 		times at the beginning and the end of the trajectory duration, and 
> 		the  initial values of the trajectories $\vec{x}$ at time $u_0$.
> 
> 
> If the continuous dynamics of $\vec{x}$ is specified as a system of ODEs
> $\frac{\mathrm{d}\vec{x}}{\mathrm{d}t}= F_{\vec{a}}(\vec{x},t)$
> for a control command $\vec{a}$
> during a time interval $[u_0,u_t]$, 
> then the formula $\phi_{E_M}$ 
> includes universal quantification over time along with solutions of the ODEs, such as a formula of the form:
> \[
> \bigvee \big(\mathit{guard}(\vec{a}) \rightarrow
> \forall t \in [u_0,u_t].\;
> \vec{x}(t) = \vec{v} + \int_0^{t-u_0} \!  F_{\vec{a}}(\vec{x},t)\,\mathrm{d}t
> \big)
> \]
> %For example, 
> %the formula $\phi_{E_M}(\mathit{rate}_M,u_0,u_t,v_M \shortmid \alpha_M)$
> %for 
> %%an environment 
> %$E_M$ of a subcontroller $M$ in the airplane example is given by:
> %$\forall t \in [u_0, u_t].\; \alpha_M(t) = v_M + \int_0^{t-u_0}  \mathit{rate}_M \,\mathrm{d}t$.
> %where the surface angle $\alpha_M$ follows the ODE
> %$\frac{\mathrm{d}\alpha_M}{\mathrm{d}t} = \mathit{rate}_M$
> %from the current angle $v_M$ in the time interval $[0,u]$.
> 
> 
> \begin{definition}
> For %a physical environment 
> $E_M = (C, \vec{x}, \Lambda)$,
> %the formula $\phi_{E_M}$ is defined as
> $\phi_{E_M}(\vec{a},u_0,u_t,\vec{v} \shortmid \vec{x})$
> iff
> $((\vec{a},u_t-u_0,\vec{v}), \vec{\tau}) \in \Lambda$
> and $\vec{x}(t) = \vec{\tau}(t - u_0)$ for $t \in [u_0, u_t]$.
> \end{definition}
> 
> The encoding $\phi_{M \restriction_\pi E_M}$ of the 
>  environment restriction $M \restriction_\pi E_M$
> has the form
> $\phi_{M \restriction_\pi E_M}^{T,i}(\vec{i}, \vec{y}, \vec{v} \shortmid \vec{y'}, \vec{v'}, \vec{o})$,
> with variables:
> \begin{inparaenum}[(i)]
> 	\item $\vec{i}$ denoting input, 
> 	\item $(\vec{y},\vec{v})$ denoting a state  at the beginning of the round 
> 		(at time $iT - \epsilon$),
> 	\item $(\vec{y'},\vec{v'})$ denoting a state at the end of the round 
> 		(at time $(i+1)T - \epsilon$), and 
> 	\item $\vec{o}$ denoting output.
> \end{inparaenum}
> %
> Instead of  writing $iT - \epsilon$ and $(i+1)T - \epsilon$  in $\phi_{M \restriction_\pi E_M}$,
> we use the ``$\epsilon$-shifted''  time axis for the interval $[iT, (i+1)T]$. %for the formula $\phi_{M \restriction_\pi E_M}$.
> %
> %A formula $\phi_{M \restriction_\pi E_M}$ 
> %is basically the direct translation of its formal definition in Definition~\ref{def:env-res}.
> Due to clock skews, 
> the exact values of sampling time $u_I = (c_M(i)+t_I)-(iT-\epsilon)$
> and response time $u_R = (c_M(i)+t_R)-(iT-\epsilon)$ are unknown. 
> Because $iT - \epsilon < c_M(i) < iT + \epsilon$,
> we represent those times as formulas 
> $t_I < u_I < t_I + 2\epsilon$ and $t_R < u_R < t_R + 2\epsilon$
> in $\phi_{M \restriction_\pi E_M}$.
> 
> 
> 
> 
> 
> 
> \begin{definition}
> For an environment restriction $M \restriction_\pi E_M$
> with  interface % projection functions
> $\pi$, %=(\pi_T, \pi_R, \pi_I, \pi_C, \pi_O)
> %the formula 
> $\phi_{M \restriction_\pi E_M}^{T,i}(\vec{i}, \vec{y}, \vec{v} \shortmid \vec{y'}, \vec{v'}, \vec{o})$
> is defined % from Definition~\ref{def:env-res}
> by:
> \begin{align*}
> \begin{alignedat}{3}
> \exists \vec{a},\vec{a'}, \vec{v}_I, \vec{v}_R, u_I, u_R, t_I, t_R.\;
> &&&
> \vec{a} = \pi_C(\vec{y})
> \\
> \wedge\;
> \phi_{E_M}(\vec{a},iT,iT+u_I,\vec{v} \shortmid \vec{x})
> &\;\;\wedge\;\;&&
> \vec{v}_I = \vec{x}(iT+u_I)
> \\
> \wedge\;
> \phi_{E_M}(\vec{a},iT+u_I,iT+u_R,\vec{v}_I \shortmid \vec{x})
> &\;\;\wedge\;\;&&
> \vec{v}_R = \vec{x}(iT+u_R)
> \\
> \wedge\;
> \phi_M(\vec{i},\langle\vec{y},\pi_O(\vec{v}_I)\rangle \shortmid \langle\vec{y'},\pi_O(\vec{v'})\rangle, \vec{o})
> &\;\;\wedge\;\;&&
> \vec{a'} = \pi_C(\vec{y'})
> \\
> \wedge\;
> \phi_{E_M}(\vec{a'},iT+u_R, (i+1)T ,\vec{v}_R \shortmid \vec{x})
> &\;\;\wedge\;\;&&
> \vec{v'} = \vec{x}((i+1)T)
> \\
> \wedge\;
> t_I = \pi_I(\vec{y})
> &\;\;\wedge\;\;&&
> t_R = \pi_R(\vec{y},\vec{i})
> \end{alignedat}
> \\
> \begin{alignedat}{3}
> \wedge\;
> (t_I < u_I < t_I + 2\epsilon)
> \;\wedge\;
> (t_R < u_R < t_R + 2\epsilon)
> \end{alignedat}
> \end{align*}
> %
> Notice that a local clock $c_M$ (and the round number $\pi_T$)
> are abstracted from the formula.
> That is,
> $\phi_{M \restriction_\pi E_M}(\vec{i}, s, \vec{v} \shortmid s', \vec{v'}, \vec{o})$
> iff
> $( (\vec{i}, (s,\vec{v})), ((s',\vec{v'}), \vec{o}) ) \in \delta_{M \restriction_\pi E_M}$
> for some $c_M$.
> \end{definition}
> 
> 
> 
> 
> \subsection{Encoding Hybrid Ensembles}
> 
> %Recall that 
> The synchronous composition  of an ensemble 
> $\mathcal{E}$ is equivalent to a single machine $M_\mathcal{E}$
> in which all machines perform their transitions in lockstep.
> Each fast machine $f$  performs $k = \mathit{rate}(f)$  internal transitions in one step.
> %
> The encoding
> $\phi_{(M \restriction_\pi E_M)^{\times k}}^{T, i}$
> of the $k$-step \emph{deceleration} of %an environment restriction 
> $M \restriction_\pi E_M$
> is defined by sequentially 
> composing the 
> $k$ formulas $\phi_{M \restriction_\pi E_M}^{T/k,ik},\ldots,\phi_{M \restriction_\pi E_M}^{T/k,(ik+k-1)}$
> corresponding  to the $k$  \emph{subintervals} $[(ik+n-1)T/k-\epsilon,(ik+n)T/k-\epsilon]$ 
> for $n=1,\ldots,k$.
> 
> \begin{definition}
> Given $M \restriction_\pi E_M$ and $k \in \mathbb{N}$,
> the formula
> $\phi_{(M \restriction_\pi E_M)^{\times k}}^{T,
>   i}(\langle\vec{i_1},\ldots,\vec{i_k}\rangle, \vec{y_0}, \vec{v_0}
> \shortmid \vec{y}_{k}, \vec{v}_{k},
> \langle\vec{o_1},\ldots,\vec{o_k}\rangle)$ is: 
> \[
> %(\exists \vec{y_1},\ldots, \vec{y}_{k-1}, \vec{v_1},\ldots, \vec{v}_{k-1})
> \exists\{\vec{y_n}, \vec{v_n}\}_{n=1}^{k-1}.\,
> \bigwedge_{n=1}^k \phi_{M \restriction_\pi E_M}^{T/k,(ik+n-1)}(\vec{i_n}, \vec{y}_{n-1}, \vec{v}_{n-1} \shortmid \vec{y_{n}}, \vec{v_{n}}, \vec{o}_n)
> \]
> \end{definition}
> 
> The wiring diagram of $\mathcal{E}$ is encoded as
> a conjunction of %appropriate 
> equalities between variables denoting input and output ports.
> Each equality corresponds to a connection in $\mathcal{E}$
> (together with an input adaptor for machines with different rates).
> %Since feedback outputs of one machine to itself or another machine 
> %becomes input of their destinations in the next step,
> %we use a separate set of variables for such output ports connected to other machines in $\mathcal{E}$.
> %$\phi_\mathit{wire}$ is a conjunction of equalities, together with
> %the input adaptors of $\{M_j\}_{j\in J_S\cup J_F}$,  given by the
> %wiring diagram of $\mathcal{E}$. 
> 
> 
> \begin{definition}
> %The formula 
> $\phi_\mathit{wire}$ is the conjunction of the equalities:
> \begin{inparaenum}[(i)]
> 	\item $\alpha_j^l(i_j^l) = i_e^n$
> 	for each connection from $\mathcal{E}$'s $n$-th input port to $M_j$'s $l$-th input port 
> 	with its input adaptor $\alpha_j^l$;
> 	\item $o_e^n = o_j^l$
> 	for each connection from $M_j$'s $l$-th output port to $\mathcal{E}$'s $n$-th output port; and
> 	\item $\alpha_j^l(i_j^l) = f_k^n$ and ${f_k^n}' = o_k^n$
> 	for each connection from $M_k$'s $n$-th output port to $M_j$'s $l$-th input port with its input adaptor $\alpha_j^l$,
> 	where $f_k^l$ denotes a feedback output from the previous step, 
> 	and ${f_k^l}'$ denotes one for the next step.
> \end{inparaenum}
> \end{definition}
> 
> 
> A hybrid ensemble $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$ 
> of machines  $\{M_j\}_{j\in J_S\cup J_F}$ with %physical 
> environments $\{E_{M_j}\}_{j\in J_S\cup J_F}$
> ($J_S$ denoting slow machines and $J_F$ denoting fast machines) is
> encoded as a formula 
> $\phi_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}^{T,i}(
> 	\vec{i}, \{\vec{z_j},\vec{f_j}\}_{j\in J_S\cup J_F}
> 	\shortmid 
> 	\{\vec{z'_j}, \vec{f_j'}\}_{j\in J_S\cup J_F}, \vec{o})$,
> %
> with variables $\vec{i}$, $\vec{z_j}$, $\vec{f_j}$, $\vec{z_j'}$,
> $\vec{f_j'}$, and $\vec{o}$ denoting, respectively, 
> inputs, the state of $M_j \restriction_{\pi_j} E_{M_j}$ at the beginning of the round 
> 		(at time $iT - \epsilon$),
> feedback outputs from the previous round,
> 	the  state of $M_j \restriction_{\pi_j} E_{M_j}$ at the end of the round 
> 		(at time $(i+1)T - \epsilon$), 
> the feedback outputs for the next round,	and 
> the output.
> 
> 
> \begin{definition}
> For a hybrid ensemble $\mathcal{E} \restriction_{\Pi} E_\mathcal{E}$, %of machines 
> %$\{M_j\}_{j\in J_S\cup J_F}$, their physical environments $\{E_{M_j}\}_{j\in J_S \cup J_F}$
> %and the time-invariant constraint $(\forall t.\; \psi)$,
> its encoding
> $\phi_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}^{T,i}(
> 	\vec{i}, \{\vec{y_j}, \vec{v_j},\vec{\mathit{f}_j}\}_{j\in J_S\cup J_F}
> 	\shortmid 
> 	\{\vec{y'_j}, \vec{v'_j}, \vec{\mathit{f}_j'}\}_{j\in J_S\cup J_F}, \vec{o})$ is:
> \begin{align*}
> %(\exists \{\vec{i_j},\vec{o_j}\}_{j\in J_S\cup J_F})\;
> \exists \{\vec{i_j},\vec{o_j}\}_{j\in J_S\cup J_F}.\,
> \textstyle\bigwedge_{s \in J_S}
> \big(\phi_{M_s \restriction_{\pi_s} E_{M_s}}^{T,i}(\vec{i_s}, \vec{y_s}, \vec{v_s} \shortmid \vec{y'_s}, \vec{v'_s}, \vec{o}_s)\big)
> \phantom{.}
> \\
> \wedge\;
> \textstyle\bigwedge_{f \in J_F}
> \big(\phi_{(M_f \restriction_{\pi_f} E_{M_f})^{\times\mathit{rate}(j)}}^{T,i}(\vec{i_f}, \vec{y_f}, \vec{v_f} \shortmid \vec{y'_f}, \vec{v'_f}, \vec{o}_f)\big)
> \phantom{.}
> \\
> \wedge\;
> \phi_\mathit{wire}(\vec{i},\vec{o},\{\vec{i_j},\vec{o_j},\vec{\mathit{f}_j},\vec{\mathit{f}_j'}\}_{j\in J_S\cup J_F})
> \;\wedge\;
> (\forall t.\; \psi).
> \end{align*}
> \end{definition}
> 
> By construction, a formula $\phi_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}^{T,i}$ is satisfiable
> iff there is a corresponding transition of the synchronous composition $M_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}$
> from $iT - \epsilon$ to $(i+1)T - \epsilon$ for \emph{some} local clocks.
> Therefore, by  the bisimulation equivalence (Theorem~\ref{thm:hybrid-pals}):
> 
> \begin{theorem}\label{thm:pals-encoding}
> $\phi_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}^{T,i}$ is satisfiable 
> iff for some local clocks, there exists a corresponding \emph{stable transition} in a distributed hybrid system  
> $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$   for $[iT - \epsilon,(i+1)T - \epsilon]$.
> \end{theorem}
> 
> \subsection{Encoding Verification Problems}
> 
> Our goal is to verify safety properties
> of a distributed CPS $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$.
> In general, a safety property of the system can be expressed as a formula of the form 
> $\forall t.  \mathit{safe}(\vec{z},t)$
> for  state variables $\vec{z}$ and time variable $t$.
> 
> 
> %For bounded analysis
> To verify %whether $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$
> a safety property %$\forall t.  \mathit{safe}(\vec{z},t)$
> up to a given bound $n \in \mathbb{N}$
> (i.e., for the time interval $[0,nT - \epsilon]$),
> we encode its \emph{bounded counterexamples}. %of $\forall t.  \mathit{safe}(\vec{z},t)$
> %up to the bound $n$.
> If the formula is unsatisfiable (i.e., no counterexample exists), 
> then, by Theorem~\ref{thm:pals-encoding},  the system satisfies the safety property in $[0,nT - \epsilon]$
> \emph{for any local clocks}.
> 
> 
> 
> \begin{definition}
> The verification problem for $\forall t.  \mathit{safe}(\vec{z},t)$
> %of $\mathcal{MA}(\mathcal{E}, T, \Gamma) \restriction_{\Pi} E_\mathcal{E}$ 
> \emph{up to $n$ rounds} with  initial condition $\mathit{init}(\vec{z})$
> is encoded by:
> \begin{align*}
> \exists \vec{z}_0, \{\vec{z}_k, \vec{i}_k, \vec{o}_k, t_k\}_{k=1}^{n}.\;
> \textstyle\bigwedge_{k=1}^{n}
> \big(\phi_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}^{T,k}(
> 	\vec{i}_k, \vec{z}_{k-1}
> 	\shortmid 
> 	\vec{z}_{k}, \vec{o}_k)\big)
> \phantom{.}
> \\
> \wedge\;
> \mathit{init}(\vec{z}_0)
> \;\wedge\;
> \textstyle\bigvee_{k=1}^{n}
> \big(
> (k-1)T < t_{k} \leq T
> \wedge
> \neg\mathit{safe}(\vec{z}_k, t_{k}) 
> \big).
> \end{align*}
> \end{definition}
> 
> 
> For \emph{unbounded} verification of a safety property,
> we encode its inductive proof as a logical formula.
> The idea is to find an inductive condition $\mathit{ind}(\vec{z})$ 
> for synchronous transitions
> that corresponds to the beginning of a global round,
> and to show that $\mathit{ind}(\vec{z})$ implies %the safety property 
> $\mathit{safe}(\vec{z},t)$ 
> for that round.
> 
> \begin{definition} 
> The  verification problem for $\forall t. \mathit{safe}(\vec{z},t)$
> with an inductive condition $\mathit{ind}(\vec{z})$ is encoded  by:
> \begin{multline*}
> \forall \vec{z}, \vec{z'}, \vec{i}, \vec{o}.\;
> (\mathit{ind}(\vec{z})\;\wedge\;\phi_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}^{T,0}(\vec{i}, \vec{z}\shortmid \vec{z'}, \vec{o}))
> \\
> \implies
> \mathit{ind}(\vec{z'}) \;\wedge\; t \in [0,T].\,\mathit{safe}(\vec{z},t)
> .
> \end{multline*}
> \end{definition}
> 
> We also encode a divide-and-conquer proof
> to verify a safety property by compositional analysis. % as formulas.
> An input condition $\mathit{c}_\mathit{in}(\vec{i},\vec{z},t)$
> and an output condition $\mathit{c}_\mathit{out}(\vec{o},\vec{z},t)$ 
> during a global round
> are identified for synchronous transitions
> in such a way 
> that $\mathit{c}_\mathit{in}(\vec{i},\vec{z},t)$ implies %the safety property 
> $\mathit{safe}(\vec{z},t)$ for that round.
> %(time variable $t$ is included because of time-invariant constraints).
> %This method is very useful for parameterized systems (see Section~\ref{sec:case-studies}).
> 
> 
> \begin{definition} \label{def:compositional}
> The compositional analysis for $\forall t.  \mathit{safe}(\vec{z},t)$
> with I/O conditions $\mathit{c}_\mathit{in}(\vec{i},\vec{z},t)$ and $\mathit{c}_\mathit{out}(\vec{o},\vec{z},t)$
> is encoded by:
> \begin{multline*}
> \forall \vec{z}, \vec{z'}, \vec{i}, \vec{o}.\;
> (\mathit{c}_\mathit{in}(\vec{i},\vec{z},t)
> \;\wedge\;
> \phi_{\mathcal{E} \restriction_{\Pi} E_\mathcal{E}}^{T,0}(
> 	\vec{i}, \vec{z}
> 	\shortmid 
> 	\vec{z'}, \vec{o})
> )
> \\
> \implies
> \mathit{c}_\mathit{out}(\vec{o},\vec{z'},t) \;\wedge\; t \in [0,T].\, \mathit{safe}(\vec{z},t).
> \end{multline*}
> \end{definition}
> 
> The validity of such formulas for inductive or compositional  analysis can also be automatically checked 
> using SMT solving
> by checking the unsatisfiability of their \emph{negations}.
> 
> 
> 
> 
> 
> 
> 
> 
> 
Only in /Users/kquine/Downloads/texfiles/: smt-logic-1.tex
Only in .: thermo-error.png
Only in .: water-error.png
Only in .: water.graffle
Only in .: water.pdf
