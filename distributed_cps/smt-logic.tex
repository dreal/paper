% !TEX root = /Users/kquine/Dropbox/Research/Papers/2015/CPS-SMT-RTSS/cps-rtss.tex


\section{Efficient SMT Procedure}
\label{sec:smt-logic}

\textbf{First, explain $\delta$-complete SMT}

A \emph{$\delta$-complete decision procedure} for an SMT formula $\phi$ returns false 
if $\phi$ is unsatisfiable, and returns true if its %syntactic 
numerical perturbation of $\phi$ by bound $\delta$ is satisfiable. 
This is practically very useful since 
sampling exact values of physical parameters is not possible in reality. 


We first recall the theory of the real numbers with real functions.

\begin{definition}
Let $\mathcal{F}$ denote a finite collection of computable real functions,
such as polynomials, %trigonometric functions,  
and solutions of %Lipschitz-continuous 
ODEs.
%(real number constants are given as $0$-ary functions).
%
$\mathcal{L}_\mathcal{F} = (\mathcal{F}, >)$ denotes the first-order signature over the real numbers
with the functions in $\mathcal{F}$,
and $\mathbb{R}_\mathcal{F} = (\mathbb{R}, \mathcal{F}^\mathbb{R}, >^\mathbb{R})$
is the standard structure of the theory of the real numbers.
\end{definition}

Note that $\delta$-complete SMT problems are the satisfiability of
$\mathcal{L}_\mathcal{F}$-formulas over $\mathbb{R}_\mathcal{F}$.

\textbf{Second, uninterpreted function symbols not supported for state-of-the-art SMT}

% $\delta$-complete 
An SMT problem for a hybrid system uses
 the theory of  real numbers with computable real functions
and ODEs.

Checking the satisfiability of such formulas with uninterpreted real functions
and universal quantification is generally a nontrivial problem. (not supported)


\textbf{We develop a new SMT logic for efficiently encode and analyze hybrid systems}


This section presents a new logical framework
to provide an efficient decision procedure for 
SMT formulas generated by the new encoding.

\textbf{First explain the encoding, and then the formal way}


\subsection{Theory of the Real Numbers with Function Names}


\textbf{difficulties for dealing with unint. func. sym.?}

A conflict-based 

It is not easy to \emph{statically check without} $\delta$-complete decision procedures
whether such subformulas of the form $\forall t \in [0,T].\; g(t) = \mathit{flow}_q(\vec{x})(t)$
are $\delta$-consistent to each other or not.

Even though two real functions
$f_1(t)$ and $f_2(t)$ have completely different forms, 
their corresponding formulas 
can be consistent up to a given precision $\delta > 0$.
E.g.,
for $f_1(t) = \sqrt{t+1}$ and $f_2(t) = 1 + \frac{1}{2}t - \frac{1}{8}t^2 + \frac{1}{16}x^3$,
where $f_2(t)$ is the third order taylor expansion of $\sqrt{t+1}$,
the formulas 
$\forall t \in [0,T].\; g(t) = f_1(t)$ and  $\forall t \in [0,T].\; g(t) = f_2(t)$
are consistent up to precision $\delta = 0.1$ for $T = 0.8$,
but not consistent if  $\delta = 0.01$.

We need the underlying $\mathcal{T}$-solver
to decide their consistency up to $\delta > 0$
(e.g., by checking the unsatisfiability of the formula
$\exists t \in [0,T].\; f_1(t) \neq f_2(t)$).


%



Instead of directly using extra function symbols and universal quantification,
we use another logical theory 
extending the standard theory of the real numbers with computable functions.

Formal analysis of hybrid systems
can still be encoded as SMT formulas by means of Formulas~(\ref{eq:new-bounded}--\ref{eq:comp-bounded})
in this theory.
But universal quantification is not needed anymore,
and thus it provides simple yet more efficient decision procedures.
%
The point is that for parallel compositions of hybrid automata,
%the full expressive power of extra function symbols and universal quantification is not necessary,
 we only need to indicate which flow corresponds to a given mode of a component.





For the new encoding, % in Section~\ref{sec:effective-encoding},
for each $i$-th step,
$\mathcal{F}$ also includes \emph{uninterpreted} function symbols
$\vec{x}_i$ for the variables $X$
and $g_i$ for extra function symbols.
%Instead, we consider another theory without using uninterpreted function symbols.

We consider a \emph{two-sorted} first-order logic with sorts $\mathit{Real}$ and $\mathit{Name}$.
As expected, $\mathit{Real}$ denotes real numbers,
and $\mathit{Name}$ denotes \emph{name constants} that corresponds to 
unary real functions composed of the functions in $\mathcal{F}$.
For example, given $\{1, +, \times, \sin, x, y\} \subset \mathcal{F}$, 
we can have the real functions
$\sin(t) :\mathit{Real} \to \mathit{Real}$,
$x(t) :\mathit{Real} \to \mathit{Real}$,
and
$[y(t) + 1, z(t)^2] :  \mathit{Real} \to \mathit{Real}^2$.
Their names can be given by name constants 
$\texttt{sin}$, $\texttt{flw1}$, and  $\texttt{flw2}$ of sort $\mathit{Name}$.
%
A collection of the application operators $\mathit{app}^n : \mathit{Name} \times \mathit{Real} \to \mathit{Real}^n$
connect a name constant to its underlying function with range $\mathit{Real}^n$, e.g.,
$\mathit{app}^1(\texttt{sin}, 0) = \sin(0)$,
$\mathit{app}^1(\texttt{flw1}, 3) = x(3)$,
and
$\mathit{app}^2(\texttt{flw2}, u) = 
[y(u) + 1,z(u)^2]$.

Unlike the previous approach,
%in this logic 
we explicitly take into account
a collection of the integral operators $\mathit{int}^{k_1,\ldots,k_n} : 
\mathit{Name}^n \times \mathit{Real} \to \mathit{Real}^{\sum_{i=1}^n k_i}$.
An integral term
$\mathit{int}^{k_1,\ldots,k_n}(\nu_1,\ldots,\nu_n,t)$
takes a list of name constants $\nu_1,\ldots,\nu_n$,
to respectively denote real functions $f_1,\ldots,f_n$ with ranges $\mathit{Real}^{k_1},\ldots,\mathit{Real}^{k_n}$,
and time value $t$,
and returns the value $\int_0^t \, [f_1(t),\ldots,f_n(t)] \,\mathrm{d}t$.  
These integral operators are very useful for generating SMT formulas
for parallel compositions of hybrid automata,
since ODE literals can be constructed in a modular way
and thus the size of the formula can be much reduced.
For example:
\[
%\mathit{int}^{2}(\texttt{flw1}, u) 
%= 
%\int_0^t 
%\left[\begin{array}{l}y(u) + 1\\z(u)^2\end{array}\right]
%\mathrm{d}t,
%\\
\mathit{int}^{1,2}(\texttt{flw1},\texttt{flw2}, u) 
= 
\int_0^t 
[x(t),y(u) + 1,z(u)^2]
\mathrm{d}t.
\]

\begin{definition}
Let $\mathcal{N}$ be a  set of name constants,
and  $\mathcal{O}$ be a set  of new operators %application operators 
$\mathit{app}^n$
and %integral operators 
$\mathit{int}^{k_1,\ldots,k_n}$.
%
The first order signature is defined by 
$\mathcal{L}_{\mathcal{F}\cup\mathcal{N}} = (\mathcal{F} \cup \mathcal{N} \cup \mathcal{O}, >)$.
For a fixed set $N$ of \emph{name objects},
the first order structure is defined by
$\mathbb{R}_{\mathcal{F}\cup\mathcal{N}} 
= (\mathbb{R} \cup N, \mathcal{F}^\mathbb{R} \cup \mathcal{N}^N \cup \mathcal{O}^{N,\mathbb{R}}, >^\mathbb{R})$
in which the interpretation $\mathcal{N}^N$ of name constants and 
the interpretation $\mathcal{O}^{N,\mathbb{R}}$ of application and integral operators 
are given as explained above.
\end{definition}

Notice that the signature $\mathcal{L}_\mathcal{F}$ is a subsignature of $\mathcal{L}_{\mathcal{F}\cup\mathcal{N}}$,
and the structure $\mathbb{R}_\mathcal{F}$ for the real numbers 
is a substructure of $\mathbb{R}_{\mathcal{F}\cup\mathcal{N}}$.
The syntax and semantics of $\mathcal{L}_{\mathcal{F}\cup\mathcal{N}}$-formulas 
is defined by means of $\mathcal{L}_{\mathcal{F}\cup\mathcal{N}}$ and $\mathbb{R}_{\mathcal{F}\cup\mathcal{N}}$
in the standard way.


Because the $\mathcal{L}_{\mathcal{F}\cup\mathcal{N}}$-formulas for the new encoding
only add name constants and existentially quantified name variables,
their decision procedure %for those formulas
 is simple and need no extra cost.

We can statically add \emph{uniqueness lemmas} of the form
$\neg (w = \texttt{flow}_q \;\wedge\; w = \texttt{flow}_{q'})$ for any pair of $q \neq q'$,
and this can significantly reduce the Boolean search space.

We first find a truth assignment for the names, and 
replace names in ODEs by them

We have a truth assignment that includes only $\mathcal{L}_\mathcal{F}$-terms.
The satisfiability of such $\mathcal{L}_\mathcal{F}$-assignments
can then be decided by using $\delta$-decision procedures as usual.

\begin{theorem}
Some decision procedure?
\end{theorem}

or exploiting the theory of equalities.



\subsection{Encoding}

Equality  constraints, such as $x_1(t) = x_2(t)$, 
 can be removed
from the formula by replacing equal with equal
(for example, by replacing each function symbol $x_1$ with  $x_2$).



%However, 
For networks of hybrid systems,
the standard SMT encoding tends to yield a formula 
including many ODE literals. 
For %a network of hybrid systems given by 
a parallel composition
 $H_1 \parallel \ldots \parallel H_n$, % of several hybrid automata,
the formula for $k$-step bounded model checking  
has $N = (k+1) \cdot \prod_{i = 1\ldots n} m_i$ ODE literals,
where each $H_i$ has $m_i$ modes.
The size of the formula is 
$O(k \cdot \prod_{i = 1}^n m_i)$.



The reason why standard SMT formulas for networks of hybrid automata include so many ODE literals 
is that the syntax of the underlying logic 
(i.e., the theory of the real numbers with computable functions)
is \emph{not} modular  for ODEs. %restrictive
Since solutions of ODEs %given by integral operators, 
are considered as \emph{atomic} functions in this logic,
%any information from 
the structure of the underlying hybrid automaton 
cannot be used to express ODE solution functions.
Our goal is to explicitly take into account the structure of a hybrid automaton
for SMT-based analysis.



The basic idea is to decompose a single ODE literal
into a conjunction of several literals according to its underlying structure.
%Logically, this can be achieved by using extra function symbols and universal quantification.
%
Consider a $l$-dimensional ODE literal
$\vec{y}^t = \vec{y}^0 + \textstyle\int_{0}^T \mathit{flow}(\vec{x}) \,\mathrm{d}t$.
Mathematically,
a variable $x \in \vec{x}$ in $\mathit{flow}(\vec{x})$ 
can be considered a unary function $\mathbb{R} \to \mathbb{R}$,
%
and thus
the term $\mathit{flow}(\vec{x})$ can also be considered as a unary function
$\mathbb{R} \to \mathbb{R}^l$.
%
Therefore, 
using an extra function symbol $g : \mathbb{R} \to \mathbb{R}^l$
and the state function symbols $\vec{x}(t)$,
the ODE literal can be rewritten as the logically equivalent conjunction: 
\[
\vec{y}^t = \vec{y}^0 + \textstyle\int_{0}^T g(t)  \,\mathrm{d}t
\quad\wedge\quad
\forall t \in [0,T].\; g(t) = \mathit{flow}(\vec{x})(t).
\]
%


%
Therefore, SMT-based analysis for networks of hybrid systems
can easily suffer from the \emph{formula explosion problem}
that makes such %SMT-based
 analysis practically infeasible.
%even for small networked hybrid systems.
%
The above technique 
is particularly useful for a parallel composition $H_1 \parallel \ldots \parallel H_n$,
since an ODE literal can be decomposed with respect to its components $H_1, \ldots, H_n$.
%which is not possible in the standard encoding.
Let $\overrightarrow{\vec{x}} = [\vec{x}_{1},\ldots,\vec{x}_{n}]$ 
$\overrightarrow{\vec{x}}^t = [\vec{x}_{1}^t,\ldots,\vec{x}_{n}^t]$
and $\overrightarrow{\vec{x}}^0 = [\vec{x}_{1}^0,\ldots,\vec{x}_{n}^0]$
denote $n$-vectors of state variable vectors.
Consider a single \emph{concrete} ODE literal
\[
\overrightarrow{\vec{x}}^t
=
\overrightarrow{\vec{x}}^0
+
\int_0^T
[\mathit{flow}_1(\overrightarrow{\vec{x}}),\ldots,\mathit{flow}_n(\overrightarrow{\vec{x}})]\,\mathrm{d}t.
\]
By using $n$ extra function symbols $g_1, \ldots, g_n$ that 
respectively correspond to $H_1, \ldots, H_n$,
we have a logically equivalent conjunction 
\begin{align*}
\overrightarrow{\vec{x}}^t
=
\overrightarrow{\vec{x}}^0
+
\int_0^T
[g_1(t),\ldots,g_n(t)]
\,\mathrm{d}t
\;\wedge\;
\\
\bigwedge_{i = 1}^n
\forall t \in [0,T].\,
g_i(t) = \mathit{flow}_i(\overrightarrow{\vec{x}})(t).
\end{align*}



In a way similar to the above,
%Similarly,
the composed continuous behavior for duration $T$ 
with respect to arbitrary flows $\overrightarrow{g} = [g_1,\ldots,g_n]$ 
in $(q_1,\ldots,q_n) \in Q_1 \times \cdots \times Q_n$ 
from values $\overrightarrow{\vec{x}}^0$ to $\overrightarrow{\vec{x}}^t$
is then expressed as the formula:
\[
\begin{medsize}
\begin{aligned}
\mathit{cont}_{\overrightarrow{g}}(\overrightarrow{\vec{x}}^0, \overrightarrow{\vec{x}}^t,
\overrightarrow{m}, T)
\;\equiv\;
\overrightarrow{\vec{x}}^t
= 
\overrightarrow{\vec{x}}^0
+ 
\int_{0}^T 
[g_1(t),\ldots,g_n(t)]
\,\mathrm{d}t
\;\wedge\;
\\
\forall U \in [0,T]\;
\forall \overrightarrow{\vec{x}}^u \in \val(X_1 \cup \cdots \cup X_n).\;
\\
\overrightarrow{\vec{x}}^u
 = 
\overrightarrow{\vec{x}}^0
+ 
\int_{0}^U 
[g_1(t),\ldots,g_n(t)]
\,\mathrm{d}t 
\,\to\,
\mathit{inv}(\overrightarrow{m},\overrightarrow{\vec{x}}^u).
\end{aligned}
\end{medsize}
\]




SMT formulas for hybrid systems by the new encoding
can be rewritten in this logic without using uninterpreted real functions 
and universal quantification.
Each extra function symbol $g_i$ is replaced by a name variable $w_i$, and
each subformula of the form $(\forall t \in [0,T_i].\; g_i(t) = \mathit{flow}_q(\vec{x})(t))$
is replaced by an equality $w_i = \texttt{flow}_q$,
where name \emph{constant} $\texttt{flow}_q$ denotes the flow function $\mathit{flow}_q(\vec{x})(t)$.
For example, 
the continuous behavior of $H$ with respect to name variable $w_i$
is expressed as the formula:
\[
\begin{multlined}
\mathit{cont}(w_i, \vec{x}_i^0, \vec{x}_i^t, m_i, T_i) \;\equiv\;
(\vec{x}_i^t = \vec{x}_i^0 + \mathit{int}^l(w_i, T_i))
\,\wedge\,
\\
\forall U \in [0,T]\;
\forall \vec{x}^u \in \val(X).\;
(\vec{x}_i^u = \vec{x}_i^0 + \mathit{int}^l(w_i, U)) \,\to\, \mathit{inv}(m_i,\vec{x}_i^u),
\end{multlined}
\]
and the formula for $k$-step bounded model checking of $H$
is rewritten as the following formula including equality terms  $w_0 = \texttt{flow}_q$ and $w_i = \texttt{flow}_{q'}$:
\[
\begin{medsize}
\begin{alignedat}{2}
\exists m_0,\ldots,m_k\;
\exists w_0,\ldots,w_k\;
\exists \vec{x}_0, \ldots, %\vec{x}_k, \vec{x}_0^t, \ldots, 
\vec{x}_k^t \in \val(X)\;
\exists T_0, \ldots, T_k \in [0,T_{\max}].
\\
\mathit{cont}(w_0, \vec{x}_0^0, \vec{x}_0^t, m_0, T_0)
\,\wedge\,
\textstyle
\bigvee_{q \in Q}
\big(
m_0 = q 
\,\wedge\,
\mathit{init}_q(\vec{x}_0^0) 
\,\wedge\,
w_0 = \texttt{flow}_q
\big)
\,\wedge\,
\\
\bigwedge_{i = 1}^k 
\mathit{cont}(w_i,\vec{x}_i^0, \vec{x}_i^t, m_i, T_i)
\,\wedge\,
\bigvee_{q, q' \in Q}
\left(
\begin{aligned}
m_{i-1} = {q}
\,\wedge\,
m_i = {q'}
\,\wedge\,
\\
\mathit{jump}_{q,q'}(\vec{x}_{i-1}^t,\vec{x}_{i}^0)
\,\wedge\,
w_i = \texttt{flow}_{q'}
\end{aligned}
\right)
\,\wedge\,
\neg \mathit{safe}(\vec{x}_k^t)
\end{alignedat}
\end{medsize}
\]

%We can easily see that the above formula has indeed the same meaning as
% Formula~(\ref{eq:bounded}) for the standard encoding 
% as follows.
%(which is also equivalent to Formula~(\ref{eq:new-bounded})).

\begin{theorem}
Formulas~(\ref{eq:new-bounded}--\ref{eq:comp-bounded})
for formal analysis of hybrid systems rewritten in $\mathcal{L}_{\mathcal{F}\cup\mathcal{N}}$ 
are equivalent to the corresponding formulas in the standard encoding.% $\mathbb{R}_{\mathcal{F}\cup\mathcal{N}} $

%Each extra function symbol $g_i$ is replaced by a name variable $w_i$, and
%each subformula of the form $(\forall t \in [0,T_i].\; g_i(t) = \mathit{flow}_q(\vec{x})(t))$
%is replaced by an equality $w_i = \texttt{flow}_q$,

\end{theorem}

\begin{proof}
This immediately follows from 
$\mathbb{R}_\mathcal{F} \subseteq \mathbb{R}_{\mathcal{F}\cup\mathcal{N}}$ and
the formula rewriting process in Section~\ref{sec:effective-encoding}.
Consider the above 
$\mathcal{L}_{\mathcal{F}\cup\mathcal{N}}$ formula for $k$-step bounded model checking.
For the initial step, by distributing %the term 
$\mathit{cont}(w_0, \vec{x}_0^0, \vec{x}_0^t, m_0, T_0)$
over %the disjunction 
$\bigvee_{q \in Q}
(m_0 = q 
\:\wedge\:
\mathit{init}_q(\vec{x}_0^0) 
\;\wedge\;
w_0 = \texttt{flow}_q)$,
we have the equivalent formula
$\bigvee_{q \in Q}
(m_0 = q 
\:\wedge\:
\mathit{init}_q(\vec{x}_0^0) 
\;\wedge\;
w_0 = \texttt{flow}_q
\;\wedge\;
\mathit{cont}(w_0, \vec{x}_0^0, \vec{x}_0^t, m_0, T_0))$.
By replacing %the variable 
$w_0$ by $\texttt{flow}_q$, we have
$\bigvee_{q \in Q}
(m_0 = q 
\:\wedge\:
\mathit{init}_q(\vec{x}_0^0) 
\;\wedge\;
\mathit{cont}(\texttt{flow}_q, \vec{x}_0^0, \vec{x}_0^t, m_0, T_0))$.
%
Since the integral term $\mathit{int}^l(\texttt{flow}_q, T_0)$
denotes the function $\int_0^{T_0} \mathit{flow}_q(\vec{x})\,\mathrm{d}t$ of $T_0$,
 $\mathit{cont}(\texttt{flow}_q, \vec{x}_0^0, \vec{x}_0^t, m_0, T_0)$
is equivalent to $\mathit{cont}_{\vec{x}_0}^q(\vec{x}_0^0, \vec{x}_0^t, T_0)$.
Therefore,
the $0$-step formula
is equivalent to
$\bigvee_{q \in Q}
\big(
m_0 = q 
\:\wedge\:
\mathit{init}_q(\vec{x}_0^0) 
\:\wedge\:
\mathit{cont}_{\vec{x}_0}^q(\vec{x}_0^0, \vec{x}_0^t, T_0)\big)$,
i.e., the $0$-step in Formula~(\ref{eq:bounded}).
The other cases are similar.
\end{proof}


