\section{The Test-and-Infer Loop}

Testing is an incomplete method of checking specifications of a
function. It samples points from the domain of a function and checks
whether properties hold at those points or not. Sampling larger number
of points may give higher confidence on the correctness of a function.
However, it is practically infeasible to sample all the points in the
domain even if the domain is bounded and this remains testing
incomplete. For example, there are more than $10^{18}$ double-precision
floating-point numbers between $0.0$ and $1.0$. In a modern computer,
it takes more than a second to test an implementation of sine function
on $10^9$ points. It means that it takes more than 30 years to give a
complete coverage on the implementation for the interval $[0.0, 1.0]$.

Test-and-infer is an approach to enhance this weakness of testing.
Whenever it samples a point $c$ from the domain and test a property,
it infers a neighbor $I = [c - \delta, c + \delta]$ of the point $c$
which shares the same test result at point $c$. Using the technique,
we can efficiently cover a region of a domain by testing a point and
it accelerates the overall verification process. In our experiment
shows that it takes about XXX minutes to check a property of sine
implementation on the same interval $[0, 1]$.

\subsection{The Main Algorithm}
We want to partition a given subset $S \subseteq \mathbb{R}$ of the
domain of a nonlinear elementary function $f : \mathbb{R} \to
\mathbb{R}$ into two sets of intervals:
\begin{align*}
  G & = \{ [l, u] \mid \forall x \in [l, u]. \; | F_f(x) - f(x) | \le \varepsilon \}\\
  B & = \{ [l, u] \mid \forall x \in [l, u]. \; | F_f(x) - f(x) | > \varepsilon \}
\end{align*}
where $F_f$ denotes the function encoding the program. The set $G$
represents a set of points which satisfy the specification while the
set $B$ represents all points which possibly violate the
specification.

\begin{algorithm}
  \centering
  \caption{Test-and-Infer}
  \label{fig:test-and-infer}
  \begin{algorithmic}[1]
    \Procedure{Test-and-Infer}{$f$, $F_f$, $l$, $u$, $\varepsilon$}
        \State $G \gets \{\}$
        \State $B \gets \{\}$
        \State $c \gets l$
        \While{$c \le u$}
            \If {$ |f(c) - F_f(c)| \le \varepsilon$}
                % Good
                \State $P(x) \gets |f(x) - F_f(x)| \le \varepsilon$
                \State $r \gets \mathrm{Infer}(P, r, \delta)$
                \State $G \gets G \cup
                                \{ [c - r, c + r] \}$
            \Else
                % Bad
                \State $P(x) \gets |f(x) - F_f(x)| > \varepsilon$
                \State $r \gets \mathrm{Infer}(P, r, \delta)$
                \State $B \gets B \cup
                                \{ [c - r, c + r] \}$
            \EndIf
            \State $c \gets c + r$
        \EndWhile
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \centering
  \caption{Infer}
  \label{fig:good}
  \begin{algorithmic}[1]
    \Procedure{Infer}{$P$, $\delta$, $r$}
        \While{true}
            \State $R \gets Solve_{\delta}(\exists x. \; |x - c| \le r \land \neg P(x))$
            \If {$ R = UNSAT$}
                % There is no x violating the property within
                % [c - \delta, c + \delta]
                \State \Return $r$
            \ElsIf {$R = \delta$-$SAT$ with $x \mapsto c'$}
                % \delta-SMT finds a counterexample c'
                \If {$\neg P(c')$}
                    % c' is a good point
                    \State $r \gets |c - c'|$
                    \Comment $\delta$-$SAT \to SAT$
                \Else
                    % c' is a bad point
                    \State $\delta \gets \delta / 2$
                    \Comment $\delta$-$SAT \to UNSAT$
                \EndIf
            \EndIf
        \EndWhile
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

Algorithm~\ref{fig:test-and-infer} illustrates the main algorithm of our
approach. Given a function $f$, a range $[l, u]$, and an error-bound
$\varepsilon$, \texttt{Test-and-Infer} returns the two sets $G$ and
$B$. After initialization (line 2 - 4), it executes $f(c)$ and store
the result at $r$ (line 6).

\subsection{Encoding the Implementation}

Show many snippets of the code.


\subsection{Verifying Good Intervals}

For each good input $a\in \mathbb{R}$ and error bound $\varepsilon$,
we find a neighborhood $I$ around $a$ such that
$$\forall x\in I.\; |F_{\sin}(x)-\sin(x)|\leq \varepsilon$$
where $F_{\sin}$ denotes the function encoding the program.

By triangle inequality, we have
\begin{eqnarray}
|F_{\sin}(x) - \sin(x)| \leq |F_{\sin}(x) - \sin(a)| + |\sin(x) - \sin(a)|,
\end{eqnarray}
and we only need to show

\begin{eqnarray}
\forall x\in I.\; |F_{\sin}(x) - \sin(a)| + |\sin(x) - \sin(a)| \leq \varepsilon.
\end{eqnarray}

For this, we can check satisfiability of the negation of the formula, i.e.:
\begin{eqnarray}
\exists x\in I.\; |F_{\sin}(x) - \sin(a)| + |\sin(x) - \sin(a)| > \varepsilon.
\end{eqnarray}

With Taylor expansion, we know
\begin{eqnarray}
|\sin(x) - \sin(a)| > \cos(a) |x - a| - \frac{\sin(a)}{2}(x-a)^2 + ... %check it
\end{eqnarray}

Thus, we only need to show
\begin{eqnarray}
\exists x\in I.\; |F_{\sin}(x) - \sin(a)| + \cos(a) |x - a| -
\frac{\sin(a)}{2}(x-a)^2 > \varepsilon.
\end{eqnarray}

The program encoding can be sliced based on monitoring on the input.
Basically we only need the slice that's used in producing the output.

\subsection{Debugging Bad Intervals}

For a bad input $b$ and error bound $\varepsilon$, we aim to find a
neighborhood $I$ around $b$ such that the error always exhibits:

$$ \forall x\in I.\; |F_{\sin}(x) - \sin(x)| > \varepsilon$$

The bad cases usually come from some bugs in the program. For that we
can have a formula encoding conditions on intermediate variables.
Formalize this ...

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
