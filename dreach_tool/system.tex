\section{\dReach{}: System Description}
\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{images/dReach}
  \caption{Architecture of \dReach{}: It consists of an bounded
    model-checking module and an SMT solver, \dReal{}. In the first
    phase, the BMC module translate an input hybrid system into a
    logic formula with respect to the specified unrolling bound $k$
    and the provided reachability condition $\textit{goal}$ in the
    model. In the second phase, an SMT solver, \dReal{}, solves the
    encoded $\delta$-reachability problem.}
  \label{fig:system-description}
\end{figure}

Figure~\ref{fig:system-description} illustrates the architecture of
\dReach{}. We provide a domain-specific lanaguage to describe a hybrid
system and specify its safety properties. Given an input model,
specification, and unrolling bound $k$, \dReach{} reduces the
$\delta$-reachability problem to a $\delta$-decision problem of
formulae over the reals by providing a corresponding SMT encoding for
the problem. Then, the bounded reachability queries are answered by
using our nonlinear SMT solver \dReal{}~\cite{DBLP:conf/cade/GaoKC13}.

\subsection{Encoding Bounded Reachability Problem}

Our previous work~\cite{DBLP:journals/corr/GaoKCC14} already studied
logic encodings of bounded reachability problems of hybrid
systems. The encoding scheme is based on the standard bounded model
checking while non-trivial mode invariants and systems with
nondeterministic flows make the problem interesting.

In this section, we explain the extensions and variable naming
convention that we make to the standard SMT-LIB~\cite{BarST-SMT-10} to
represent flows and mode invariants of hybrid systems.

\paragraph{Variable naming convention}
In our encoding, a system variable $\texttt{x\_i\_p}$ has two
subscripts $i \in \mathbb{N}$ and $p \in \{0, t\}$. The first
subscript $i$ indicates that it represents the value of a system
variable $x$ at the $i$-th step. The second subscript $p \in \{0, t\}$
denotes the value at the begining of mode (end of mode,
respectively). For instance, $x\_0\_t$ denotes the value of variable
$x$ at the end of first mode (step 0).

\paragraph{\texttt{define-ode} and \texttt{integral}}
Many hybrid systems formulate their flows implicitly using
the Picard-Lindel$\ddot{o}$f representation:
\[
[x\_1\_t, x\_2\_t, \dots, x\_n\_t] = \int_0^t \vec{g}([x_1(s), x_2(s), \cdots,
x_n(s)]) \mathrm{d}s.
\]
In \dReach{}, we use \texttt{define-ode} to name a flow by assigning
a name to it. Then \texttt{integral} connects the value of the initial
and final variables. For instance, the following example

\begin{Verbatim}[fontfamily=courier]
(define-ode flow_1 ((= d/dt[x] v) (= d/dt[v] -9.8)))
(integral 0 time_0 [x_0_0 v_0_0] flow_1)
\end{Verbatim}

defines a flow $\dot{x} = \int_0^t v(s) \mathrm{d}s$ and $\dot{v} =
\int_0^t -9.8 \mathrm{d}s$ and assigns a name $\mathit{flow_1}$ to it.
Command \texttt{integral} establish the relationship between the value
of varialbes at the beginning of a mode and at the end of it.

\paragraph{\texttt{forall\_t}}
\begin{Verbatim}[fontfamily=courier]
(forall_t 2 [0 time_3] (>= x_3_t 0))
\end{Verbatim}

\begin{figure}[!h]
  \centering
  \begin{Verbatim}[fontfamily=courier, frame=single, framesep=1mm,
  numbers=left, fontsize=\scriptsize]
(set-logic QF_NRA_ODE)
(declare-fun x () Real)
(declare-fun v () Real)
(declare-fun x_0_0 () Real)
(declare-fun x_0_t () Real)
...
(declare-fun x_10_0 () Real)
(declare-fun x_10_t () Real)
(declare-fun v_0_0 () Real)
(declare-fun v_0_t () Real)
...
(declare-fun v_10_0 () Real)
(declare-fun v_10_t () Real)
(declare-fun time_0 () Real)
...
(declare-fun time_10 () Real)
(declare-fun mode_0 () Real)
...
(declare-fun mode_10 () Real)
(define-ode flow_1 ((= d/dt[x] v)
                    (= d/dt[v] (+ (- 0.0 9.8) (* -0.45 (^ v 1.0))))))
(define-ode flow_2 ((= d/dt[x] v)
                    (= d/dt[v] (+ (- 0.0 9.8) (* -0.45 (^ v 1.0))))))
(assert (<= 0.0 x_0_0))
(assert (<= x_0_0 15.0))
...
(assert (<= -18.0 v_10_t))
(assert (<= v_10_t 18.0))
(assert (<= 0.0 time_0))
(assert (<= time_0 3.0))
...
(assert (<= 0.0 time_10))
(assert (<= time_10 3.0))
...

(assert (and (and (= v_0_0 0.0) (>= x_0_0 5.0)) (= mode_0 1.0) (=
[x_0_t v_0_t] (integral 0. time_0 [x_0_0 v_0_0] flow_1)) (= mode_0
1.0) (forall_t 1.0 [0.0 time_0] (<= v_0_t 0.0)) (<= v_0_t 0.0) (<=
...
x_9_t) (= [x_10_t v_10_t] (integral 0. time_10 [x_10_0 v_10_0]
flow_1)) (= mode_10 1.0) (forall_t 1.0 [0.0 time_10] (<= v_10_t 0.0))
(<= v_10_t 0.0) (<= v_10_0 0.0) (forall_t 1.0 [0.0 time_10] (>= x_10_t
0.0)) (>= x_10_t 0.0) (>= x_10_0 0.0) (= mode_10 1.0) (>= x_10_t
0.45))) (check-sat) (exit)
\end{Verbatim}
  \caption{SMT2 encoding of the bounded reachability problem of
    bouncing ball ($k = 3$) }
  \label{fig:bouncing-ball-smt2}
\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
